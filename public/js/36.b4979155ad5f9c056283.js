(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[36],{

/***/ "./node_modules/laue/dist/laue.js":
/*!****************************************!*\
  !*** ./node_modules/laue/dist/laue.js ***!
  \****************************************/
/*! exports provided: Laue, Cartesian, Polar, Line, Area, Bar, Pie, XAxis, YAxis, XAxisInverse, YAxisInverse, Tooltip, Legend, YMarker, YRegion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Laue\", function() { return Laue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cartesian\", function() { return Cartesian; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Polar\", function() { return Polar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return Line; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Area\", function() { return Area; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bar\", function() { return Bar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pie\", function() { return Pie; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XAxis\", function() { return XAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"YAxis\", function() { return YAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XAxisInverse\", function() { return XAxisInverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"YAxisInverse\", function() { return YAxisInverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tooltip\", function() { return Tooltip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Legend\", function() { return Legend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"YMarker\", function() { return YMarker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"YRegion\", function() { return YRegion; });\n/*!\n * Laue v0.2.1\n * https://laue.js.org\n *\n * Copyright (c) 2018 qingwei-li\n * Licensed under the MIT license\n */\n\nfunction isFn(o) {\n  return typeof o === 'function'\n}\n\nfunction isArr(o) {\n  return Array.isArray(o)\n}\n\nfunction isNil(o) {\n  return o === null || o === undefined\n}\n\nfunction isNum(n) {\n  return !isNaN(n)\n}\n\nfunction extend(to, _from) {\n  // eslint-disable-next-line\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n\n  return to\n}\n\nfunction noNilInArray(arr) {\n  return !arr.some(isNil)\n}\n\nfunction noop() {}\n\nfunction debounce(fn, delay) {\n  if ( delay === void 0 ) delay = 20;\n\n  var id;\n\n  return function () {\n    var i = arguments.length, argsArray = Array(i);\n    while ( i-- ) argsArray[i] = arguments[i];\n\n    clearTimeout(id);\n    id = setTimeout.apply(void 0, [ fn, delay ].concat( argsArray ));\n  }\n}\n\nvar slice = Array.prototype.slice;\n\nfunction constant(x) {\n  return function constant() {\n    return x;\n  };\n}\n\nfunction offsetNone(series, order) {\n  if (!((n = series.length) > 1)) { return; }\n  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (j = 0; j < m; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n}\n\nfunction orderNone(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0) { o[n] = n; }\n  return o;\n}\n\nfunction stackValue(d, key) {\n  return d[key];\n}\n\nfunction stack() {\n  var keys = constant([]),\n      order = orderNone,\n      offset = offsetNone,\n      value = stackValue;\n\n  function stack(data) {\n    var kz = keys.apply(this, arguments),\n        i,\n        m = data.length,\n        n = kz.length,\n        sz = new Array(n),\n        oz;\n\n    for (i = 0; i < n; ++i) {\n      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {\n        si[j] = sij = [0, +value(data[j], ki, j, data)];\n        sij.data = data[j];\n      }\n      si.key = ki;\n    }\n\n    for (i = 0, oz = order(sz); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n\n    offset(sz, oz);\n    return sz;\n  }\n\n  stack.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : keys;\n  };\n\n  stack.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), stack) : value;\n  };\n\n  stack.order = function(_) {\n    return arguments.length ? (order = _ == null ? orderNone : typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : order;\n  };\n\n  stack.offset = function(_) {\n    return arguments.length ? (offset = _ == null ? offsetNone : _, stack) : offset;\n  };\n\n  return stack;\n}\n\nfunction stackOffsetDiverging(series, order) {\n  if (!((n = series.length) > 1)) { return; }\n  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {\n    for (yp = yn = 0, i = 0; i < n; ++i) {\n      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {\n        d[0] = yp, d[1] = yp += dy;\n      } else if (dy < 0) {\n        d[1] = yn, d[0] = yn += dy;\n      } else {\n        d[0] = yp;\n      }\n    }\n  }\n}\n\nvar plane = {\n  props: {\n    data: {\n      type: Array,\n      default: function () { return []; }\n    },\n\n    height: {\n      type: Number,\n      default: 300\n    },\n\n    width: {\n      type: Number,\n      default: 600\n    },\n\n    autoresize: Boolean,\n\n    padding: {\n      default: 8,\n      type: [Number, Array]\n    },\n\n    stacked: Boolean,\n\n    /**\n     * The default colors is \"walden\" from ECharts\n     * @see http://echarts.baidu.com/theme-builder/\n     */\n    colors: {\n      default: function () { return [\n        '#3fb1e3',\n        '#6be6c1',\n        '#626c91',\n        '#a0a7e6',\n        '#c4ebad',\n        '#96dee8'\n      ]; },\n      type: [Array, Function]\n    },\n\n    textColor: {\n      type: String,\n      default: '#999'\n    }\n  },\n\n  computed: {\n    offset: function offset() {\n      var ref = this;\n      var padding = ref.padding;\n      var space = ref.space;\n      var pad = [];\n\n      for (var i = 0; i < 4; i++) {\n        var p = isArr(padding) ? padding[i] || 0 : padding;\n        var s = space[i];\n        pad[i] = isFn(p) ? p(s) : s + p;\n      }\n\n      return pad\n    },\n\n    viewWidth: function viewWidth() {\n      var ref = this;\n      var parentWidth = ref.parentWidth;\n      var width = ref.width;\n      return isNil(parentWidth) ? width : parentWidth\n    },\n\n    canvas: function canvas() {\n      var ref = this;\n      var viewWidth = ref.viewWidth;\n      var height = ref.height;\n      var offset = ref.offset;\n      var x0 = offset[3];\n      var y0 = offset[0];\n      var y1 = height - offset[2];\n      var x1 = viewWidth - offset[1];\n\n      return {\n        x0: x0,\n        y0: y0,\n        width: x1 - x0,\n        height: y1 - y0,\n        x1: x1,\n        y1: y1\n      }\n    },\n\n    curData: function curData() {\n      return stack()\n        .keys(this.props)\n        .offset(this.stacked ? stackOffsetDiverging : noop)(this.data)\n    }\n  },\n\n  provide: function provide() {\n    return {\n      Plane: this\n    }\n  },\n\n  methods: {\n    genColor: function genColor(index) {\n      var ref = this;\n      var colors = ref.colors;\n\n      if (isArr(colors)) {\n        return colors[index % colors.length]\n      }\n\n      return colors(index)\n    },\n\n    resize: function resize() {\n      var ref = this.$el.getBoundingClientRect();\n      var width = ref.width;\n      this.parentWidth = width;\n    },\n\n    addSpace: function addSpace(space) {\n      var this$1 = this;\n      if ( space === void 0 ) space = [];\n\n      space.forEach(function (val, i) {\n        this$1.space[i] = Math.max(val, this$1.space[i] || 0);\n      });\n    }\n  },\n\n  data: function () { return ({\n    space: [0, 0, 0, 0],\n    parentWidth: null,\n    props: [],\n    store: {}\n  }); },\n\n  mounted: function mounted() {\n    if (this.autoresize) {\n      this.resize();\n      if (typeof window !== 'undefined') {\n        window.addEventListener('resize', debounce(this.resize));\n      }\n    }\n  }\n}\n\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nfunction tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) { step1 *= 10; }\n  else if (error >= e5) { step1 *= 5; }\n  else if (error >= e2) { step1 *= 2; }\n  return stop < start ? -step1 : step1;\n}\n\nfunction int(str) {\n  return parseInt(str, 10)\n}\n\n/**\n * Returns nick ticks\n */\nfunction genTicks(min, max, count) {\n  var assign;\n\n  if (max < min) {\n    (assign = [max, min], min = assign[0], max = assign[1]);\n  }\n\n  if (min === 0 && max === 0) {\n    return [0]\n  }\n\n  var step = tickStep(min, max, count);\n  var first = Math.floor(min / step) * step;\n  var ticks$$1 = [first];\n  var cur = first;\n\n  while (cur < max) {\n    cur += step;\n    ticks$$1.push(cur);\n  }\n\n  if (Math.abs(min - ticks$$1[1]) < step) {\n    ticks$$1.shift();\n    ticks$$1[0] = min;\n  }\n\n  if (Math.abs(max - ticks$$1[ticks$$1.length - 2]) < step) {\n    ticks$$1.pop();\n    ticks$$1[ticks$$1.length - 1] = max;\n  }\n\n  return ticks$$1\n}\n\nfunction genExactNbTicks(min, max, count) {\n  var diff = max - min;\n  var step = diff / (count - 1);\n  var ticks$$1 = [];\n\n  for (var i = 0; i < count; i++) {\n    ticks$$1.push(i * step);\n  }\n\n  ticks$$1.push(max);\n\n  return ticks$$1\n}\n\nfunction bound(data, type, key) {\n  return Math[type].apply(\n    Math, data.map(function (arr) { return Math[type].apply(Math, arr.map(function (item) { return item[key]; }).filter(isNum)); })\n  )\n}\n\nvar Cartesian = {\n  name: 'LaCartesian',\n\n  mixins: [plane],\n\n  props: {\n    bound: {\n      type: Array,\n      default: function () { return []; }\n    },\n\n    narrow: [Boolean, Number, Function],\n\n    distance: {\n      default: 0,\n      type: Number\n    }\n  },\n\n  computed: {\n    high: function high() {\n      return this.getBound(this.bound[1], 'max')\n    },\n\n    low: function low() {\n      return this.getBound(this.bound[0], 'min')\n    },\n\n    len: function len() {\n      return this.data.length\n    },\n\n    tempXRatio: function tempXRatio() {\n      var ref = this;\n      var len = ref.len;\n      return len <= 1 ? 0 : this.canvas.width / (len - 1)\n    },\n\n    gap: function gap() {\n      var ref = this;\n      var narrow = ref.narrow;\n      var tempXRatio = ref.tempXRatio;\n\n      if (isFn(narrow)) {\n        return narrow(tempXRatio)\n      }\n      if (narrow === true) {\n        return tempXRatio / 2\n      }\n      return Number(narrow)\n    },\n\n    xRatio: function xRatio() {\n      return this.tempXRatio ?\n        this.tempXRatio - 2 * this.gap / (this.len - 1) :\n        0\n    },\n\n    yRatio: function yRatio() {\n      return this.canvas.height / (this.high - this.low || 1)\n    }\n  },\n\n  methods: {\n    getBound: function getBound(val, type) {\n      if (typeof val === 'number') {\n        return val\n      }\n\n      var isMin = type === 'min';\n      var result = bound(this.curData, type, isMin ? 0 : 1);\n\n      if (isMin && result === 0) {\n        result = bound(this.curData, 'min', 1);\n      }\n\n      if (isFn(val)) {\n        return val(result)\n      }\n\n      return result\n    }\n  },\n\n  /**\n   * @todo Need to optimize. The Props changes will call update even if it does not need.\n   * https://github.com/vuejs/vue/issues/5727\n   */\n  render: function render(h) {\n    var this$1 = this;\n\n    var ref = this;\n    var viewWidth = ref.viewWidth;\n    var height = ref.height;\n    var autoresize = ref.autoresize;\n    var slots = this.$slots.default || [];\n\n    /**\n     * Reset snap\n     */\n    this.snap = {};\n\n    var props = [];\n    var cartesians = [];\n    var objects = [];\n    var widgets = [];\n    var others = [];\n\n    slots.forEach(function (slot) {\n      var options = slot.componentOptions;\n      if (!options) {\n        others.push(slot);\n        return\n      }\n      var sealed = options.Ctor.sealedOptions;\n      if (!sealed) {\n        return\n      }\n      var propsData = options.propsData;\n      var prop = propsData.prop;\n\n      switch (sealed.type) {\n        case 'cartesian':\n          if (prop && props.indexOf(prop) < 0) {\n            props.push(prop);\n          }\n          slot.index = cartesians.length;\n          cartesians.push(slot);\n          break\n        case 'object':\n          this$1.addSpace(sealed.space);\n          objects.push(slot);\n          break\n        case 'widget':\n          widgets.push(slot);\n          break\n        default:\n          break\n      }\n      if (sealed.preload) {\n        sealed.preload({data: propsData, parent: this$1, index: slot.index});\n      }\n    });\n\n    this.props = props;\n\n    return h(\n      'div',\n      {\n        style: {\n          position: 'relative',\n          width: autoresize ? '100%' : viewWidth + 'px'\n        }\n      },\n      [\n        h(\n          'svg',\n          {\n            attrs: {\n              width: viewWidth,\n              height: height,\n              viewBox: (\"0 0 \" + viewWidth + \" \" + height)\n            }\n          },\n          [others, cartesians, objects]\n        ),\n        widgets\n      ]\n    )\n  }\n}\n\nvar Polar = {\n  name: 'LaPolar',\n\n  mixins: [plane],\n\n  props: {\n    fillContainer: Boolean\n  },\n\n  computed: {\n    min: function min() {\n      return Math.min(this.viewWidth, this.height)\n    }\n  },\n\n  render: function render(h) {\n    var ref = this;\n    var viewWidth = ref.viewWidth;\n    var height = ref.height;\n    var autoresize = ref.autoresize;\n    var slots = this.$slots.default || [];\n\n    /**\n     * Reset snap\n     */\n    this.snap = {};\n\n    var props = [];\n    var polars = [];\n    var widgets = [];\n    var others = [];\n\n    slots.forEach(function (slot) {\n      var options = slot.componentOptions;\n      if (!options) {\n        others.push(slot);\n        return\n      }\n      var sealed = options.Ctor.sealedOptions;\n      if (!sealed) {\n        return\n      }\n      var propsData = options.propsData;\n      var prop = propsData.prop;\n\n      switch (sealed.type) {\n        case 'polar':\n          if (prop && props.indexOf(prop) < 0) {\n            props.push(prop);\n          }\n          slot.index = polars.length;\n          polars.push(slot);\n          break\n        case 'widget':\n          widgets.push(slot);\n          break\n        default:\n          break\n      }\n    });\n\n    this.props = props;\n\n    return h(\n      'div',\n      {\n        style: {\n          position: 'relative',\n          width: autoresize ? '100%' : viewWidth + 'px'\n        }\n      },\n      [\n        h(\n          'svg',\n          {\n            attrs: {\n              width: this.fillContainer ? '100%' : viewWidth,\n              height: this.fillContainer ? '100%' : height,\n              viewBox: this.fillContainer ? (\"0 0 \" + (this.min) + \" \" + (this.min)) : (\"0 0 \" + viewWidth + \" \" + height),\n              preserveAspectRatio: 'xMinYMin'\n            }\n          },\n          [others, polars]\n        ),\n        widgets\n      ]\n    )\n  }\n}\n\nvar basic = {\n  inject: ['Plane'],\n\n  computed: {\n    store: function store() {\n      return this.Plane.store\n    }\n  }\n}\n\nvar values = {\n  props: {\n    prop: String\n  },\n\n  mixins: [basic],\n\n  computed: {\n    raws: function raws() {\n      var ref = this;\n      var prop = ref.prop;\n      var Plane = ref.Plane;\n\n      return prop ? Plane.data.map(function (o) { return o[prop]; }) : null\n    },\n\n    values: function values() {\n      var ref = this;\n      var prop = ref.prop;\n      var Plane = ref.Plane;\n\n      return Plane.curData.filter(function (arr) { return arr.key === prop; })[0] || []\n    }\n  }\n}\n\nvar animate = {\n  props: {\n    animated: Boolean,\n\n    animationDuration: {\n      default: 1,\n      type: Number\n    },\n\n    animationEffect: {\n      default: 'ease',\n      type: String\n    },\n\n    transition: String\n  },\n\n  computed: {\n    trans: function trans() {\n      return (\n        this.transition ||\n        (this.animated ?\n          (\"all \" + (this.animationDuration) + \"s \" + (this.animationEffect)) :\n          'none')\n      )\n    }\n  }\n}\n\nvar chart = {\n  mixins: [values, animate],\n\n  props: {\n    points: Array,\n\n    color: String,\n\n    label: String,\n\n    showValue: Boolean\n  },\n\n  computed: {\n    id: function id() {\n      return this.$vnode.index\n    },\n\n    curColor: function curColor() {\n      return this.color || this.Plane.genColor(this.id)\n    },\n\n    actived: function actived() {\n      var ref = this.store;\n      var hidden = ref.hidden;\n\n      if (!isArr(hidden)) {\n        return true\n      }\n\n      return hidden.indexOf(this.id) < 0\n    }\n  },\n\n  watch: {\n    'store.activedIndex': function store_activedIndex(index) {\n      var ref = this;\n      var store = ref.store;\n\n      store.activedPoint = [].concat(store.activedPoint);\n\n      this.$set(store.activedPoint, this.id, {\n        color: this.curColor,\n        value: this.raws[index],\n        label: this.label\n      });\n    },\n\n    curColor: {\n      immediate: true,\n      handler: function handler(val) {\n        var ref = this;\n        var store = ref.store;\n\n        store.colors = store.colors || {};\n        this.$set(store.colors, this.id, val);\n      }\n    },\n\n    label: {\n      immediate: true,\n      handler: function handler(val) {\n        var ref = this;\n        var store = ref.store;\n\n        store.labels = store.labels || {};\n        this.$set(store.labels, this.id, val);\n      }\n    },\n\n    props: {\n      immediate: true,\n      handler: function handler(val) {\n        var ref = this;\n        var store = ref.store;\n\n        store.props = store.props || {};\n\n        if (!isNil(this.id)) {\n          this.$set(store.props, this.id, val);\n        }\n      }\n    }\n  }\n}\n\nvar cartesian = {\n  mixins: [chart],\n\n  type: 'cartesian',\n\n  computed: {\n    curPoints: function curPoints() {\n      var this$1 = this;\n\n      if (this.points) {\n        return this.points\n      }\n\n      var ref = this.Plane;\n      var gap = ref.gap;\n      var xRatio = ref.xRatio;\n      var yRatio = ref.yRatio;\n      var low = ref.low;\n      var canvas = ref.canvas;\n      var x0 = canvas.x0;\n      var y1 = canvas.y1;\n\n      return this.values.map(function (value, i) {\n        var assign;\n\n        if (isNil(this$1.raws[i])) {\n          return [null]\n        }\n\n        var start = value[0];\n        var end = value[1];\n\n        if (start < 0) {\n          (assign = value, end = assign[0], start = assign[1]);\n        }\n\n        start = Math.max(low, start);\n\n        var y = isNaN(end) ? null : y1 - (end - low) * yRatio;\n        var y0 = isNaN(start) ? null : y1 - (start - low) * yRatio;\n        var x = x0 + xRatio * i + gap;\n\n        return [x, y, y0]\n      })\n    },\n\n    pointSlot: function pointSlot() {\n      var this$1 = this;\n\n      var scoped = this.$scopedSlots.default;\n      var actived = this.store.activedIndex;\n\n      return (\n        scoped &&\n        this.curPoints.map(function (p, i) { return scoped({\n            x: p[0],\n            y: p[1],\n            value: this$1.raws[i],\n            index: i,\n            actived: actived === i,\n            color: this$1.curColor,\n            style: {\n              transition: this$1.trans\n            }\n          }); }\n        )\n      )\n    }\n  }\n}\n\nvar pi = Math.PI,\n    tau = 2 * pi,\n    epsilon = 1e-6,\n    tauEpsilon = tau - epsilon;\n\nfunction Path() {\n  this._x0 = this._y0 = // start of current subpath\n  this._x1 = this._y1 = null; // end of current subpath\n  this._ = \"\";\n}\n\nfunction path() {\n  return new Path;\n}\n\nPath.prototype = path.prototype = {\n  constructor: Path,\n  moveTo: function(x, y) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n  },\n  closePath: function() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  },\n  lineTo: function(x, y) {\n    this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  quadraticCurveTo: function(x1, y1, x, y) {\n    this._ += \"Q\" + (+x1) + \",\" + (+y1) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) {\n    this._ += \"C\" + (+x1) + \",\" + (+y1) + \",\" + (+x2) + \",\" + (+y2) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  arcTo: function(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    var x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is the radius negative? Error.\n    if (r < 0) { throw new Error(\"negative radius: \" + r); }\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon)) {}\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      var x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n      }\n\n      this._ += \"A\" + r + \",\" + r + \",0,0,\" + (+(y01 * x20 > x01 * y20)) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n    }\n  },\n  arc: function(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r;\n    var dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is the radius negative? Error.\n    if (r < 0) { throw new Error(\"negative radius: \" + r); }\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._ += \"M\" + x0 + \",\" + y0;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._ += \"L\" + x0 + \",\" + y0;\n    }\n\n    // Is this arc empty? We’re done.\n    if (!r) { return; }\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) { da = da % tau + tau; }\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,\" + (+(da >= pi)) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n    }\n  },\n  rect: function(x, y, w, h) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + (+w) + \"v\" + (+h) + \"h\" + (-w) + \"Z\";\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nfunction Linear(context) {\n  this._context = context;\n}\n\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 1)) { this._context.closePath(); }\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: this._context.lineTo(x, y); break;\n    }\n  }\n};\n\nfunction curveLinear(context) {\n  return new Linear(context);\n}\n\nfunction x(p) {\n  return p[0];\n}\n\nfunction y(p) {\n  return p[1];\n}\n\nfunction line() {\n  var x$$1 = x,\n      y$$1 = y,\n      defined = constant(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function line(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) { output = curve(buffer = path()); }\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) { output.lineStart(); }\n        else { output.lineEnd(); }\n      }\n      if (defined0) { output.point(+x$$1(d, i, data), +y$$1(d, i, data)); }\n    }\n\n    if (buffer) { return output = null, buffer + \"\" || null; }\n  }\n\n  line.x = function(_) {\n    return arguments.length ? (x$$1 = typeof _ === \"function\" ? _ : constant(+_), line) : x$$1;\n  };\n\n  line.y = function(_) {\n    return arguments.length ? (y$$1 = typeof _ === \"function\" ? _ : constant(+_), line) : y$$1;\n  };\n\n  line.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), line) : defined;\n  };\n\n  line.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n\n  line.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n\n  return line;\n}\n\nfunction point(that, x, y) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x),\n    that._y2 + that._k * (that._y1 - y),\n    that._x2,\n    that._y2\n  );\n}\n\nfunction Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: point(this, this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) { this._context.closePath(); }\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n      case 2: this._point = 3; // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar cardinal = (function custom(tension) {\n\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n\nvar Trans = {\n  name: 'ElTrans',\n\n  functional: true,\n\n  props: ['from', 'trans'],\n\n  render: function render(h, ref) {\n    var children = ref.children;\n    var props = ref.props;\n\n    return h(\n      'transition',\n      {\n        props: {\n          appear: true\n        },\n        on: {\n          beforeAppear: function beforeAppear(el) {\n            // eslint-disable-next-line\n            for (var key in props.from) {\n              var val = props.from[key];\n              var to = el.getAttribute(key);\n\n              el.setAttribute((\"data-\" + key), to);\n              el.setAttribute(key, val);\n            }\n          },\n\n          appear: function appear(el) {\n            setTimeout(function () {\n              el.style.transition = props.trans;\n              el.style.WebkitTransition = props.trans;\n              el.style.msTransition = props.trans;\n              el.style.MozTransition = props.trans;\n\n              // eslint-disable-next-line\n              for (var key in props.from) {\n                var to = el.getAttribute((\"data-\" + key));\n\n                el.setAttribute(key, to);\n                el.removeAttribute((\"data-\" + key));\n              }\n            });\n          }\n        }\n      },\n      children\n    )\n  }\n}\n\nvar Spread = {\n  name: 'LaMotionSpread',\n\n  functional: true,\n\n  props: ['axis', 'transition'],\n\n  render: function render(h, ref) {\n    var children = ref.children;\n    var props = ref.props;\n    var parent = ref.parent;\n\n    var id = \"la-spread-\" + (parent._uid);\n    var axis = props.axis;\n    var transition = props.transition;\n\n    return h('g', [\n      h('defs', [\n        h(\n          'clipPath',\n          {\n            attrs: {\n              id: id\n            }\n          },\n          [\n            h(\n              Trans,\n              {\n                props: {\n                  from: {\n                    width: axis === 'x' ? 0 : '100%',\n                    height: axis === 'y' ? 0 : '100%'\n                  },\n                  trans: transition\n                }\n              },\n              [\n                h('rect', {\n                  attrs: {\n                    x: 0,\n                    y: 0,\n                    width: '100%',\n                    height: '100%'\n                  }\n                })\n              ]\n            )\n          ]\n        )\n      ]),\n      h(\n        'g',\n        {\n          attrs: {\n            'clip-path': (\"url(#\" + id + \")\")\n          }\n        },\n        children\n      )\n    ])\n  }\n}\n\nvar dashed = {\n  props: {\n    dashed: [Boolean, String]\n  },\n\n  computed: {\n    curDashed: function curDashed() {\n      var ref = this;\n      var dashed = ref.dashed;\n\n      return dashed === true || dashed === '' ?\n        3 :\n        dashed === false ? 'none' : dashed\n    }\n  }\n}\n\nvar Line = {\n  name: 'LaLine',\n\n  mixins: [cartesian, dashed],\n\n  props: {\n    curve: [Boolean, Function],\n\n    dot: Boolean,\n\n    width: {\n      type: Number,\n      default: 1\n    },\n\n    hideLine: Boolean,\n\n    /**\n     * @summary Like connectNulls\n     */\n    continued: Boolean\n  },\n\n  computed: {\n    draw: function draw() {\n      var ref = this;\n      var curve = ref.curve;\n      var continued = ref.continued;\n      var draw = line().defined(noNilInArray);\n\n      if (curve) {\n        draw.curve(isFn(curve) ? curve : cardinal);\n      }\n\n      return function (p) {\n        p = continued ? p.filter(noNilInArray) : p;\n        return draw(p)\n      }\n    },\n\n    valueSlot: function valueSlot() {\n      var this$1 = this;\n\n      var h = this.$createElement;\n\n      return (\n        this.showValue &&\n        h(\n          'g',\n          {\n            attrs: {\n              fill: this.curColor\n            }\n          },\n          this.curPoints.map(function (point$$1, i) {\n            return h(\n              'text',\n              {\n                attrs: {\n                  x: point$$1[0],\n                  y: point$$1[1],\n                  dy: '-0.31em',\n                  'text-anchor': 'middle'\n                }\n              },\n              this$1.raws[i]\n            )\n          })\n        )\n      )\n    }\n  },\n\n  render: function render(h) {\n    var ref = this;\n    var animated = ref.animated;\n    var width = ref.width;\n    var curPoints = ref.curPoints;\n    var curColor = ref.curColor;\n    var hideLine = ref.hideLine;\n    var trans = ref.trans;\n    var valueSlot = ref.valueSlot;\n    var pointSlot = ref.pointSlot;\n    var store = ref.store;\n    var actived = ref.actived;\n\n    if (!actived) {\n      return null\n    }\n\n    var graphs = [\n      !hideLine &&\n        h('path', {\n          attrs: {\n            stroke: curColor,\n            fill: 'none',\n            'stroke-width': width,\n            d: this.draw(curPoints)\n          },\n          style: {\n            'stroke-dasharray': this.curDashed,\n            transition: trans\n          }\n        }),\n      this.$slots.default,\n      this.dot &&\n        h(\n          'g',\n          {\n            attrs: {\n              stroke: '#fff',\n              fill: curColor\n            }\n          },\n          curPoints.map(\n            function (p, index) { return p[1] &&\n              h('circle', {\n                attrs: {\n                  cx: p[0],\n                  cy: p[1],\n                  r: (index === store.activedIndex ? 2 : 0) + int(width) + 1\n                },\n                style: {\n                  transition: trans\n                }\n              }); }\n          )\n        ),\n      valueSlot,\n      pointSlot\n    ];\n\n    if (animated) {\n      return h(\n        Spread,\n        {\n          props: {\n            axis: 'x',\n            transition: trans\n          }\n        },\n        graphs\n      )\n    }\n\n    return h('g', graphs)\n  }\n}\n\nfunction area() {\n  var x0 = x,\n      x1 = null,\n      y0 = constant(0),\n      y1 = y,\n      defined = constant(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function area(data) {\n    var i,\n        j,\n        k,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer,\n        x0z = new Array(n),\n        y0z = new Array(n);\n\n    if (context == null) { output = curve(buffer = path()); }\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k = i - 1; k >= j; --k) {\n            output.point(x0z[k], y0z[k]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n      }\n    }\n\n    if (buffer) { return output = null, buffer + \"\" || null; }\n  }\n\n  function arealine() {\n    return line().defined(defined).curve(curve).context(context);\n  }\n\n  area.x = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), x1 = null, area) : x0;\n  };\n\n  area.x0 = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), area) : x0;\n  };\n\n  area.x1 = function(_) {\n    return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : x1;\n  };\n\n  area.y = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), y1 = null, area) : y0;\n  };\n\n  area.y0 = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), area) : y0;\n  };\n\n  area.y1 = function(_) {\n    return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : y1;\n  };\n\n  area.lineX0 =\n  area.lineY0 = function() {\n    return arealine().x(x0).y(y0);\n  };\n\n  area.lineY1 = function() {\n    return arealine().x(x0).y(y1);\n  };\n\n  area.lineX1 = function() {\n    return arealine().x(x1).y(y0);\n  };\n\n  area.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), area) : defined;\n  };\n\n  area.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n  };\n\n  area.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n  };\n\n  return area;\n}\n\nvar Area = {\n  name: 'LaArea',\n\n  mixins: [Line],\n\n  props: {\n    fillColor: String\n  },\n\n  computed: {\n    draw: function draw() {\n      var ref = this;\n      var curve = ref.curve;\n      var continued = ref.continued;\n      var draw = area()\n        .y0(function (d) { return d[2]; })\n        .defined(noNilInArray);\n\n      if (curve) {\n        draw.curve(isFn(curve) ? curve : cardinal);\n      }\n\n      return function (p) {\n        p = continued ? p.filter(noNilInArray) : p;\n        return draw(p)\n      }\n    },\n\n    areaId: function areaId() {\n      return (\"la-area-\" + (this._uid) + \"-\" + (this.id))\n    },\n\n    curFillColor: function curFillColor() {\n      return this.fillColor || (\"url(#\" + (this.areaId) + \")\")\n    }\n  },\n\n  render: function render(h) {\n    var ref = this;\n    var trans = ref.trans;\n    var curPoints = ref.curPoints;\n    var curColor = ref.curColor;\n    var curFillColor = ref.curFillColor;\n    var actived = ref.actived;\n\n    if (!actived) {\n      return null\n    }\n\n    return h('g', [\n      !this.fillColor &&\n        h('defs', [\n          h(\n            'linearGradient',\n            {\n              // I don't kown why using `attrs` causes the client not to rerender if the server has already rendered.\n              domProps: {\n                id: this.areaId\n              }\n            },\n            [\n              h('stop', {\n                attrs: {\n                  'stop-color': curColor,\n                  'stop-opacity': 0.5\n                }\n              })\n            ]\n          )\n        ]),\n      h(\n        Line,\n        {\n          props: extend(extend({}, this.$props), {\n            color: curColor,\n            points: curPoints,\n            transition: trans\n          }),\n          scopedSlots: this.$scopedSlots\n        },\n        [\n          h('path', {\n            attrs: {\n              d: this.draw(curPoints),\n              fill: curFillColor\n            },\n            style: {\n              transition: trans\n            }\n          }),\n          this.$slots.default\n        ]\n      )\n    ])\n  }\n}\n\nvar DEFAULT_WIDTH = 20;\n\nvar Bar = {\n  name: 'LaBar',\n\n  mixins: [cartesian],\n\n  props: {\n    width: {\n      type: Number,\n      default: DEFAULT_WIDTH\n    }\n  },\n\n  preload: function preload(ref) {\n    var data = ref.data;\n    var parent = ref.parent;\n    var index = ref.index;\n\n    var snap = parent.snap;\n    var distance = parent.distance;\n    var width = data.width || DEFAULT_WIDTH;\n\n    snap.barMap = [].concat(snap.barMap, index);\n    snap.barAllWidth = snap.barAllWidth || 0;\n    snap.barOffset = [].concat(snap.barOffset, snap.barAllWidth);\n    snap.barAllWidth += width + distance;\n  },\n\n  computed: {\n    margin: function margin() {\n      var ref = this;\n      var id = ref.id;\n      var width = ref.width;\n      var ref$1 = this.Plane;\n      var snap = ref$1.snap;\n      var distance = ref$1.distance;\n      var stacked = ref$1.stacked;\n      var index = snap.barMap.indexOf(id);\n\n      return stacked ?\n        -width / 2 :\n        snap.barOffset[index] - (snap.barAllWidth - distance) / 2\n    },\n\n    valueSlot: function valueSlot() {\n      var this$1 = this;\n\n      var h = this.$createElement;\n\n      return (\n        this.showValue &&\n        h(\n          'g',\n          {\n            attrs: {\n              fill: '#fff'\n            }\n          },\n          this.curPoints.map(function (point, i) {\n            return h(\n              'text',\n              {\n                attrs: {\n                  x: point[0] + this$1.margin + this$1.width / 2,\n                  y: point[2] + (point[1] - point[2]) / 2,\n                  dy: '0.31em',\n                  'text-anchor': 'middle'\n                }\n              },\n              this$1.raws[i]\n            )\n          })\n        )\n      )\n    }\n  },\n\n  methods: {\n    getRect: function getRect(point) {\n      var height = point[2] - point[1];\n\n      return this.$createElement('rect', {\n        attrs: {\n          x: point[0] + this.margin,\n          y: height < 0 ? point[2] : point[1],\n          width: this.width,\n          height: Math.abs(height)\n        }\n      })\n    }\n  },\n\n  render: function render(h) {\n    var this$1 = this;\n\n    var ref = this;\n    var curPoints = ref.curPoints;\n    var curColor = ref.curColor;\n    var animated = ref.animated;\n    var trans = ref.trans;\n    var pointSlot = ref.pointSlot;\n    var valueSlot = ref.valueSlot;\n    var actived = ref.actived;\n\n    if (!actived) {\n      return null\n    }\n\n    var rects = [];\n\n    if (animated) {\n      rects = curPoints.map(function (point) {\n        return h(\n          Trans,\n          {\n            props: {\n              from: {\n                height: 0,\n                y: this$1.Plane.canvas.y1\n              },\n              trans: trans\n            }\n          },\n          [this$1.getRect(point)]\n        )\n      });\n    } else {\n      rects = curPoints.map(this.getRect);\n    }\n\n    return h(\n      'g',\n      {\n        attrs: {\n          fill: curColor\n        }\n      },\n      [].concat(rects, valueSlot, pointSlot)\n    )\n  }\n}\n\nvar polar = {\n  type: 'polar',\n\n  mixins: [chart]\n}\n\nfunction descending(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n}\n\nfunction identity(d) {\n  return d;\n}\n\nvar abs = Math.abs;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar max = Math.max;\nvar min = Math.min;\nvar sin = Math.sin;\nvar sqrt = Math.sqrt;\n\nvar epsilon$1 = 1e-12;\nvar pi$1 = Math.PI;\nvar halfPi = pi$1 / 2;\nvar tau$1 = 2 * pi$1;\n\nfunction acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);\n}\n\nfunction asin(x) {\n  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);\n}\n\nfunction pie() {\n  var value = identity,\n      sortValues = descending,\n      sort = null,\n      startAngle = constant(0),\n      endAngle = constant(tau$1),\n      padAngle = constant(0);\n\n  function pie(data) {\n    var i,\n        n = data.length,\n        j,\n        k,\n        sum = 0,\n        index = new Array(n),\n        arcs = new Array(n),\n        a0 = +startAngle.apply(this, arguments),\n        da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)),\n        a1,\n        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),\n        pa = p * (da < 0 ? -1 : 1),\n        v;\n\n    for (i = 0; i < n; ++i) {\n      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n        sum += v;\n      }\n    }\n\n    // Optionally sort the arcs by previously-computed values or by data.\n    if (sortValues != null) { index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); }); }\n    else if (sort != null) { index.sort(function(i, j) { return sort(data[i], data[j]); }); }\n\n    // Compute the arcs! They are stored in the original data's order.\n    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n\n    return arcs;\n  }\n\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), pie) : value;\n  };\n\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n  };\n\n  pie.sort = function(_) {\n    return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n  };\n\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : startAngle;\n  };\n\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : endAngle;\n  };\n\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : padAngle;\n  };\n\n  return pie;\n}\n\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\n\nfunction arcPadAngle(d) {\n  return d && d.padAngle; // Note: optional!\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0, y10 = y1 - y0,\n      x32 = x3 - x2, y32 = y3 - y2,\n      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);\n  return [x0 + t * x10, y0 + t * y10];\n}\n\n// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1,\n      y01 = y0 - y1,\n      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),\n      ox = lo * y01,\n      oy = -lo * x01,\n      x11 = x0 + ox,\n      y11 = y0 + oy,\n      x10 = x1 + ox,\n      y10 = y1 + oy,\n      x00 = (x11 + x10) / 2,\n      y00 = (y11 + y10) / 2,\n      dx = x10 - x11,\n      dy = y10 - y11,\n      d2 = dx * dx + dy * dy,\n      r = r1 - rc,\n      D = x11 * y10 - x10 * y11,\n      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),\n      cx0 = (D * dy - dx * d) / d2,\n      cy0 = (-D * dx - dy * d) / d2,\n      cx1 = (D * dy + dx * d) / d2,\n      cy1 = (-D * dx + dy * d) / d2,\n      dx0 = cx0 - x00,\n      dy0 = cy0 - y00,\n      dx1 = cx1 - x00,\n      dy1 = cy1 - y00;\n\n  // Pick the closer of the two intersection points.\n  // TODO Is there a faster way to determine which intersection to use?\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) { cx0 = cx1, cy0 = cy1; }\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\n\nfunction arc() {\n  var innerRadius = arcInnerRadius,\n      outerRadius = arcOuterRadius,\n      cornerRadius = constant(0),\n      padRadius = null,\n      startAngle = arcStartAngle,\n      endAngle = arcEndAngle,\n      padAngle = arcPadAngle,\n      context = null;\n\n  function arc() {\n    var buffer,\n        r,\n        r0 = +innerRadius.apply(this, arguments),\n        r1 = +outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) - halfPi,\n        a1 = endAngle.apply(this, arguments) - halfPi,\n        da = abs(a1 - a0),\n        cw = a1 > a0;\n\n    if (!context) { context = buffer = path(); }\n\n    // Ensure that the outer radius is always larger than the inner radius.\n    if (r1 < r0) { r = r1, r1 = r0, r0 = r; }\n\n    // Is it a point?\n    if (!(r1 > epsilon$1)) { context.moveTo(0, 0); }\n\n    // Or is it a circle or annulus?\n    else if (da > tau$1 - epsilon$1) {\n      context.moveTo(r1 * cos(a0), r1 * sin(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon$1) {\n        context.moveTo(r0 * cos(a1), r0 * sin(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    }\n\n    // Or is it a circular or annular sector?\n    else {\n      var a01 = a0,\n          a11 = a1,\n          a00 = a0,\n          a10 = a1,\n          da0 = da,\n          da1 = da,\n          ap = padAngle.apply(this, arguments) / 2,\n          rp = (ap > epsilon$1) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),\n          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n          rc0 = rc,\n          rc1 = rc,\n          t0,\n          t1;\n\n      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n      if (rp > epsilon$1) {\n        var p0 = asin(rp / r0 * sin(ap)),\n            p1 = asin(rp / r1 * sin(ap));\n        if ((da0 -= p0 * 2) > epsilon$1) { p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0; }\n        else { da0 = 0, a00 = a10 = (a0 + a1) / 2; }\n        if ((da1 -= p1 * 2) > epsilon$1) { p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1; }\n        else { da1 = 0, a01 = a11 = (a0 + a1) / 2; }\n      }\n\n      var x01 = r1 * cos(a01),\n          y01 = r1 * sin(a01),\n          x10 = r0 * cos(a10),\n          y10 = r0 * sin(a10);\n\n      // Apply rounded corners?\n      if (rc > epsilon$1) {\n        var x11 = r1 * cos(a11),\n            y11 = r1 * sin(a11),\n            x00 = r0 * cos(a00),\n            y00 = r0 * sin(a00);\n\n        // Restrict the corner radius according to the sector angle.\n        if (da < pi$1) {\n          var oc = da0 > epsilon$1 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],\n              ax = x01 - oc[0],\n              ay = y01 - oc[1],\n              bx = x11 - oc[0],\n              by = y11 - oc[1],\n              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),\n              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = min(rc, (r0 - lc) / (kc - 1));\n          rc1 = min(rc, (r1 - lc) / (kc + 1));\n        }\n      }\n\n      // Is the sector collapsed to a line?\n      if (!(da1 > epsilon$1)) { context.moveTo(x01, y01); }\n\n      // Does the sector’s outer ring have rounded corners?\n      else if (rc1 > epsilon$1) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc1 < rc) { context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw); }\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the outer ring just a circular arc?\n      else { context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw); }\n\n      // Is there no inner ring, and it’s a circular sector?\n      // Or perhaps it’s an annular sector collapsed due to padding?\n      if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) { context.lineTo(x10, y10); }\n\n      // Does the sector’s inner ring (or point) have rounded corners?\n      else if (rc0 > epsilon$1) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc0 < rc) { context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw); }\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the inner ring just a circular arc?\n      else { context.arc(0, 0, r0, a10, a00, cw); }\n    }\n\n    context.closePath();\n\n    if (buffer) { return context = null, buffer + \"\" || null; }\n  }\n\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;\n    return [cos(a) * r, sin(a) * r];\n  };\n\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : innerRadius;\n  };\n\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : outerRadius;\n  };\n\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : cornerRadius;\n  };\n\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), arc) : padRadius;\n  };\n\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : startAngle;\n  };\n\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : endAngle;\n  };\n\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : padAngle;\n  };\n\n  arc.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, arc) : context;\n  };\n\n  return arc;\n}\n\nvar Circle = {\n  name: 'LaMotionCircle',\n\n  functional: true,\n\n  props: ['r', 'transition'],\n\n  render: function render(h, ref) {\n    var children = ref.children;\n    var props = ref.props;\n    var parent = ref.parent;\n\n    var id = \"la-circle-\" + (parent._uid);\n    var transition = props.transition;\n\n    return h('g', [\n      h('defs', [\n        h(\n          'clipPath',\n          {\n            attrs: {\n              id: id\n            }\n          },\n          [\n            h(\n              Trans,\n              {\n                props: {\n                  from: {\n                    r: 0\n                  },\n                  trans: transition\n                }\n              },\n              [\n                h('circle', {\n                  attrs: {\n                    r: props.r * 1.5\n                  }\n                })\n              ]\n            )\n          ]\n        )\n      ]),\n      h(\n        'g',\n        {\n          attrs: {\n            'clip-path': (\"url(#\" + id + \")\")\n          }\n        },\n        children\n      )\n    ])\n  }\n}\n\nvar Pie = {\n  name: 'LaPie',\n\n  mixins: [polar],\n\n  props: {\n    translate: {\n      type: [String, Array],\n      default: function () { return ['50%', '50%']; }\n    },\n\n    radius: {\n      type: [Number, Array],\n      default: function () { return [0, 100]; }\n    },\n\n    angles: {\n      type: [Number, Array],\n      default: function () { return [0, Math.PI * 2]; }\n    },\n\n    showLabel: Boolean,\n\n    labelProp: {\n      type: String,\n      default: 'label'\n    }\n  },\n\n  computed: {\n    arcs: function arcs() {\n      return pie()\n        .startAngle(this.curAngles[0])\n        .endAngle(this.curAngles[1])\n        .sortValues(noop)(this.raws)\n    },\n\n    curRadius: function curRadius() {\n      var innerRadius = isArr(this.radius) ? this.radius[0] : 0;\n      var outerRadius = isArr(this.radius) ? this.radius[1] : 100;\n\n      if (this.min && this.$parent.fillContainer) {\n        outerRadius = this.min / 2;\n\n        if (this.showLabel) {\n          outerRadius -= this.min / 4;\n        }\n      }\n\n      return [innerRadius, outerRadius]\n    },\n\n    curAngles: function curAngles() {\n      var ref = this;\n      var angles = ref.angles;\n\n      return isArr(angles) ? angles : [0, angles]\n    },\n\n    draw: function draw() {\n      return arc()\n        .innerRadius(this.curRadius[0])\n        .outerRadius(this.curRadius[1])\n    },\n\n    drawText: function drawText() {\n      return arc()\n        .innerRadius((this.$parent.fillContainer ? 0 : this.curRadius[1]) * 0.7)\n        .outerRadius((this.$parent.fillContainer ? this.min : this.curRadius[1]) * 0.7)\n    },\n\n    drawTextLabels: function drawTextLabels() {\n      var innerRadius = this.$parent.fillContainer ? (this.radius[0] + this.min / 5) : this.curRadius[1] * 0.7;\n      var outerRadius = this.$parent.fillContainer ? (this.radius[0] + this.min / 5) : this.curRadius[1] * 0.7;\n\n      return arc()\n        .innerRadius(innerRadius)\n        .outerRadius(outerRadius)\n    },\n\n    min: function min() {\n      return this.$parent.min\n    },\n\n    valueSlot: function valueSlot() {\n      var this$1 = this;\n\n      if (!this.showValue) {\n        return\n      }\n      var h = this.$createElement;\n\n      return this.arcs.map(function (arc$$1, i) {\n        var point = this$1.drawText.centroid(arc$$1);\n\n        return h(\n          'text',\n          {\n            attrs: {\n              x: point[0],\n              y: point[1],\n              fill: '#fff',\n              'text-anchor': 'middle'\n            }\n          },\n          this$1.raws[i]\n        )\n      })\n    },\n\n    labels: function labels() {\n      var ref = this;\n      var labelProp = ref.labelProp;\n      var Plane = ref.Plane;\n\n      return labelProp ? Plane.data.map(function (o) { return o[labelProp]; }) : null\n    },\n\n    labelSlot: function labelSlot() {\n      var this$1 = this;\n\n      if (!this.showLabel) {\n        return\n      }\n\n      var h = this.$createElement;\n\n      return this.arcs.map(function (arc$$1, i) {\n        var point = this$1.drawTextLabels.centroid(arc$$1);\n\n        return h(\n          'text',\n          {\n            attrs: {\n              x: (point[0] * 0.95) << 1,\n              y: (point[1] * 0.95) << 1,\n              fill: '#000',\n              'text-anchor': 'middle'\n            }\n          },\n          this$1.labels[i]\n        )\n      })\n    }\n  },\n\n  render: function render(h) {\n    var this$1 = this;\n\n    var ref = this.Plane;\n    var genColor = ref.genColor;\n    var ref$1 = this;\n    var animated = ref$1.animated;\n    var arcs = ref$1.arcs;\n    var draw = ref$1.draw;\n    var paths = arcs.map(draw).map(function (d, i) {\n      return h('path', {\n        attrs: {\n          d: d,\n          fill: genColor(i),\n          stroke: '#fff'\n        }\n      })\n    });\n    var scoped = this.$scopedSlots.default;\n    var pointSlot =\n      scoped &&\n      arcs.map(function (arc$$1, i) {\n        var point = this$1.drawText.centroid(arc$$1);\n        return scoped({\n          arc: arc$$1,\n          index: i,\n          x: point[0],\n          y: point[1],\n          style: {\n            transition: this$1.trans\n          }\n        })\n      });\n    var nodes = [].concat(paths, this.valueSlot, this.labelSlot, pointSlot);\n\n    var data = {\n      style: {\n        transform: (\"translate(\" + (this.translate) + \")\")\n      }\n    };\n\n    if (animated) {\n      return h('g', data, [\n        h(\n          Circle,\n          {\n            props: {\n              transition: this.trans,\n              r: this.curRadius[1]\n            }\n          },\n          nodes\n        )\n      ])\n    }\n\n    return h('g', data, nodes)\n  }\n}\n\nvar object = {\n  mixins: [basic],\n\n  props: {\n    color: String\n  },\n\n  type: 'object',\n\n  computed: {\n    curColor: function curColor() {\n      return this.color || this.Plane.textColor\n    }\n  }\n}\n\nvar CAP_HEIGHT = 0.71;\n\nvar axes = {\n  props: {\n    color: String,\n\n    tickSize: {\n      type: Number,\n      default: 5\n    },\n\n    fontSize: {\n      type: Number,\n      default: 15\n    },\n\n    format: Function,\n\n    gridline: Boolean,\n\n    gridlineInterval: [Function, Number],\n\n    interval: [Function, Number],\n\n    ticks: Array,\n\n    nbTicks: Number\n  },\n\n  mixins: [object, values, dashed],\n\n  computed: {\n    isX: function isX() {\n      return this.$options.axis === 'x'\n    },\n\n    labels: function labels() {\n      var raws = this.raws;\n      var board = this.Plane;\n      var length = board.len;\n\n      if (this.isX) {\n        raws = raws || Array.apply(null, {length: length}).map(function (n, i) { return i + 1; });\n      } else {\n        raws = genTicks(board.low, board.high, length);\n      }\n\n      return raws\n    },\n\n    gap: function gap() {\n      return this.isX ? this.Plane.gap : 0\n    },\n\n    points: function points() {\n      var ref = this;\n      var board = ref.Plane;\n      var isX = ref.isX;\n      var labels = ref.labels;\n      var inverse = ref.inverse;\n      var gap = ref.gap;\n      var ref$1 = board.canvas;\n      var x0 = ref$1.x0;\n      var y0 = ref$1.y0;\n      var y1 = ref$1.y1;\n      var width = ref$1.width;\n      var height = ref$1.height;\n      var points;\n\n      if (isX) {\n        var xRatio = board.xRatio;\n        var offset = inverse ? 0 : height;\n        var y = y0 + offset;\n\n        points = labels.map(function (value, i) {\n          var x = x0 + xRatio * i + gap;\n\n          return [x, y]\n        });\n      } else {\n        var yRatio = board.yRatio;\n        var low = board.low;\n        var offset$1 = inverse ? width : 0;\n        var x = x0 + offset$1;\n\n        points = labels.map(function (value) {\n          var y = y1 - (value - low) * yRatio;\n\n          return [x, y]\n        });\n      }\n\n      return points\n    },\n\n    curColor: function curColor() {\n      return this.color || this.Plane.textColor\n    },\n\n    handleInterval: function handleInterval() {\n      var ref = this;\n      var interval = ref.interval;\n\n      if (typeof interval === 'number') {\n        return function (i) {\n          return i % interval === 0\n        }\n      }\n\n      if (isFn(interval)) {\n        return interval\n      }\n    },\n\n    handleGridlineInterval: function handleGridlineInterval() {\n      var ref = this;\n      var gridlineInterval = ref.gridlineInterval;\n\n      if (typeof gridlineInterval === 'number') {\n        return function (i) {\n          return i % gridlineInterval === 0\n        }\n      }\n\n      if (isFn(gridlineInterval)) {\n        return gridlineInterval\n      }\n    }\n  },\n\n  watch: {\n    'store.activedIndex': function store_activedIndex(index) {\n      if (this.isX) {\n        this.$set(this.store, 'activedLabel', this.labels[index]);\n      }\n    }\n  },\n\n  render: function render(h) {\n    var this$1 = this;\n\n    var ref = this;\n    var ticks = ref.ticks;\n\n    var ref$1 = this;\n    var nbTicks = ref$1.nbTicks;\n    var points = ref$1.points;\n    var labels = ref$1.labels;\n    var tickSize = ref$1.tickSize;\n    var fontSize = ref$1.fontSize;\n    var curColor = ref$1.curColor;\n    var isX = ref$1.isX;\n    var format = ref$1.format;\n    var inverse = ref$1.inverse;\n    var gap = ref$1.gap;\n    var board = ref$1.Plane;\n    var store = ref$1.store;\n    var first = points[0];\n    var end = points[points.length - 1];\n    var tspanSlot = this.$scopedSlots.default;\n\n    var lineSize = (inverse ? -1 : 1) * tickSize;\n    var yLineOffset = (isX ? 1 : 0) * lineSize;\n    var xLineOffset = (isX ? 0 : 1) * lineSize;\n    var textAlign = isX ? 'middle' : inverse ? 'start' : 'end';\n    var spanYOffset = isX ?\n      inverse ? CAP_HEIGHT - 1 : CAP_HEIGHT :\n      CAP_HEIGHT / 2;\n    var textYOffset = (isX ? lineSize : 0) * 1.5;\n    var textXOffset = (isX ? 0 : lineSize) * 1.5;\n\n    if (ticks || nbTicks) {\n      var yBasis = board.height - board.offset[2];\n\n      if (nbTicks) {\n        ticks = genExactNbTicks(board.low, board.high, nbTicks);\n      }\n\n      ticks = ticks.map(function (value) {\n        return h('g', [\n          tickSize &&\n            h('line', {\n              attrs: {\n                x1: 0 - xLineOffset + board.offset[3],\n                x2: 6 - xLineOffset + board.offset[3],\n                y1: yBasis - value * board.yRatio,\n                y2: yBasis - value * board.yRatio - yLineOffset,\n                stroke: curColor\n              }\n            }),\n          h(\n            'text',\n            {\n              attrs: {\n                x: 0 - textXOffset + board.offset[3],\n                y:\n                  board.height -\n                  board.offset[2] -\n                  value * board.yRatio -\n                  textYOffset,\n                dy: spanYOffset + 'em',\n                stroke: 'none'\n              }\n            },\n            tspanSlot ?\n              tspanSlot({value: value}) :\n              isFn(format) ? format(value) : value\n          )\n        ])\n      });\n    } else {\n      ticks = labels\n        .map(function (value, i) {\n          var point = points[i];\n\n          if (this$1.handleInterval && !this$1.handleInterval(i)) {\n            return false\n          }\n\n          return h('g', [\n            tickSize &&\n              h('line', {\n                attrs: {\n                  x1: point[0] - xLineOffset,\n                  x2: point[0],\n                  y1: point[1] + yLineOffset,\n                  y2: point[1],\n                  stroke: curColor\n                }\n              }),\n            h(\n              'text',\n              {\n                attrs: {\n                  x: point[0] - textXOffset,\n                  y: point[1] + textYOffset,\n                  dy: spanYOffset + 'em',\n                  stroke: 'none'\n                }\n              },\n              tspanSlot ?\n                tspanSlot({value: value}) :\n                isFn(format) ? format(value) : value\n            )\n          ])\n        })\n        .filter(Boolean);\n    }\n\n    return h(\n      'g',\n      {\n        attrs: {\n          stroke: curColor\n        }\n      },\n      [\n        h('line', {\n          attrs: {\n            x2: end[0] + gap,\n            y2: end[1],\n            x1: first[0] - gap,\n            y1: first[1]\n          }\n        }),\n        [\n          h(\n            'g',\n            {\n              attrs: {\n                'text-anchor': textAlign,\n                'font-size': fontSize,\n                fill: curColor,\n                stroke: 'none'\n              }\n            },\n            ticks\n          )\n        ].concat(\n          this.gridline &&\n            points.reduce(function (all, p, i) {\n              if (\n                !this$1.handleGridlineInterval ||\n                this$1.handleGridlineInterval(i)\n              ) {\n                all.push(\n                  h('line', {\n                    attrs: {\n                      x1: p[0],\n                      y1: p[1],\n                      x2: isX ? p[0] : board.canvas.x1,\n                      y2: isX ? board.canvas.y0 : p[1]\n                    },\n                    style: {\n                      opacity: isX && store.activedIndex === i ? 1 : 0.3,\n                      'stroke-dasharray': this$1.curDashed\n                    }\n                  })\n                );\n              }\n              return all\n            }, [])\n        )\n      ]\n    )\n  }\n}\n\nvar XAxis = {\n  name: 'LaXAxis',\n\n  axis: 'x',\n\n  space: [0, 20, 24, 20],\n\n  mixins: [axes]\n}\n\nvar YAxis = {\n  name: 'LaYAxis',\n\n  axis: 'y',\n\n  space: [10, 0, 0, 40],\n\n  mixins: [axes]\n}\n\nvar XAxisInverse = {\n  name: 'LaXAxisInverse',\n\n  space: [24, 20, 0, 20],\n\n  beforeCreate: function beforeCreate() {\n    this.inverse = true;\n  },\n\n  mixins: [XAxis]\n}\n\nvar YAxisInverse = {\n  name: 'LaYAxisInverse',\n\n  space: [10, 40, 0, 0],\n\n  beforeCreate: function beforeCreate() {\n    this.inverse = true;\n  },\n\n  mixins: [YAxis]\n}\n\nvar YMarker = {\n  name: 'LaYMarker',\n\n  mixins: [object, dashed],\n\n  props: {\n    label: String,\n\n    value: Number,\n\n    placement: {\n      type: String,\n      default: 'end'\n    }\n  },\n\n  computed: {\n    point: function point() {\n      var ref = this.Plane;\n      var yRatio = ref.yRatio;\n      var low = ref.low;\n      var canvas = ref.canvas;\n      var x0 = canvas.x0;\n      var y1 = canvas.y1;\n      var x1 = canvas.x1;\n      var y = y1 - (this.value - low) * yRatio;\n\n      return {x1: x0, y1: y, y2: y, x2: x1}\n    }\n  },\n\n  render: function render(h) {\n    var ref = this;\n    var point = ref.point;\n    var curColor = ref.curColor;\n    var curDashed = ref.curDashed;\n    var label = ref.label;\n    var placement = ref.placement;\n\n    return h(\n      'g',\n\n      [\n        h('line', {\n          attrs: point,\n          style: {\n            stroke: curColor,\n            'stroke-dasharray': curDashed\n          }\n        }),\n        label &&\n          h(\n            'text',\n            {\n              attrs: {\n                fill: curColor,\n                x:\n                  placement === 'end' ?\n                    point.x2 :\n                    placement === 'start' ?\n                      point.x1 :\n                      (point.x2 - point.x1) / 2 + point.x1,\n                y: point.y1,\n                dy: '-0.31em',\n                'text-anchor': placement\n              }\n            },\n            label\n          )\n      ]\n    )\n  }\n}\n\nvar YRegion = {\n  name: 'LaYRegion',\n\n  mixins: [object, dashed],\n\n  props: {\n    label: String,\n\n    low: {\n      type: Number,\n      required: true\n    },\n\n    high: {\n      type: Number,\n      required: true\n    },\n\n    fillColor: String,\n\n    placement: {\n      type: String,\n      default: 'end'\n    }\n  },\n\n  computed: {\n    point: function point() {\n      var ref = this.Plane;\n      var yRatio = ref.yRatio;\n      var low = ref.low;\n      var canvas = ref.canvas;\n      var x0 = canvas.x0;\n      var y1 = canvas.y1;\n      var width = canvas.width;\n\n      return {\n        x: x0,\n        y: y1 - (this.high - low) * yRatio,\n        height: (this.high - this.low) * yRatio,\n        width: width\n      }\n    },\n\n    fillAttr: function fillAttr() {\n      var ref = this;\n      var fillColor = ref.fillColor;\n\n      return fillColor ?\n        {\n          fill: fillColor,\n          stroke: this.curColor\n        } :\n        {\n          stroke: this.curColor,\n          opacity: 0.3\n        }\n    }\n  },\n\n  render: function render(h) {\n    var ref = this;\n    var label = ref.label;\n    var point = ref.point;\n    var placement = ref.placement;\n    var fillAttr = ref.fillAttr;\n\n    if (this.high < this.low) {\n      return\n    }\n\n    return h(\n      'g',\n      {\n        attrs: {\n          fill: this.curColor\n        }\n      },\n      [\n        h('rect', {\n          attrs: extend(fillAttr, point),\n          style: {\n            'stroke-dasharray': this.curDashed\n          }\n        }),\n        label &&\n          h(\n            'text',\n            {\n              attrs: {\n                x:\n                  placement === 'end' ?\n                    point.x + point.width :\n                    placement === 'start' ?\n                      point.x :\n                      point.width / 2 + point.x,\n                y: point.y,\n                dy: '-0.31em',\n                'text-anchor': placement\n              }\n            },\n            label\n          )\n      ]\n    )\n  }\n}\n\nvar widget = {\n  type: 'widget',\n\n  mixins: [basic]\n}\n\nvar Tooltip = {\n  name: 'LaTooltip',\n\n  mixins: [widget, animate],\n\n  props: {\n    animationDuration: {\n      default: 0.5,\n      type: Number\n    }\n  },\n\n  data: function () { return ({\n    left: 0,\n    top: 0,\n    show: false\n  }); },\n\n  methods: {\n    handleMove: function handleMove(ref) {\n      var x = ref.x;\n      var y = ref.y;\n\n      var board = this.Plane;\n      var boardRect = board.$el.getBoundingClientRect();\n      var rect = this.$el.getBoundingClientRect();\n      var relY = y - boardRect.y;\n      var relX = x - boardRect.x - this.offsetX;\n      var index = Math.round(relX / board.xRatio);\n      var maxLeft = board.canvas.x1 - rect.width;\n      var maxTop = board.canvas.y1 - rect.height;\n      var offset = 10;\n\n      if (relY >= board.canvas.y0 && relY <= board.canvas.y1) {\n        if (index > -1 && index < board.len) {\n          this.left = Math.min(\n            index * board.xRatio + this.offsetX + offset,\n            maxLeft\n          );\n          this.$set(this.store, 'activedIndex', index);\n          this.top = Math.min(relY + offset, maxTop);\n          this.show = true;\n        }\n        return\n      }\n      this.handleLeave();\n    },\n\n    handleLeave: function handleLeave() {\n      this.show = false;\n      this.$set(this.store, 'activedIndex', null);\n    }\n  },\n\n  computed: {\n    offsetX: function offsetX() {\n      var board = this.Plane;\n      return board.canvas.x0 + board.gap\n    }\n  },\n  mounted: function mounted() {\n    var this$1 = this;\n\n    var board = this.Plane;\n    var el = board.$el;\n\n    el.addEventListener('mousemove', debounce(this.handleMove, 10));\n    el.addEventListener('mouseleave', this.handleLeave);\n    el.addEventListener(\n      'touchmove',\n      function (e) {\n        var touch = e.touches[0];\n        this$1.handleMove({x: touch.clientX, y: touch.clientY});\n      },\n      {\n        passive: true\n      }\n    );\n  },\n\n  render: function render(h) {\n    var ref = this.store;\n    var activedLabel = ref.activedLabel;\n    var activedPoint = ref.activedPoint; if ( activedPoint === void 0 ) activedPoint = [];\n    var activedIndex = ref.activedIndex;\n    var slot = this.$scopedSlots.default;\n    var tooltip = slot ?\n      slot({\n        label: activedLabel,\n        actived: activedPoint,\n        index: activedIndex\n      }) :\n      h(\n        'div',\n        {\n          style: {\n            background: '#00000095',\n            padding: '8px',\n            color: '#fff',\n            borderRadius: '4px'\n          }\n        },\n        [\n          h(\n            'div',\n            {\n              style: {\n                marginBottom: '.5em'\n              }\n            },\n            activedLabel\n          ),\n          activedPoint.map(function (active) { return h('div', [\n              h('span', {\n                style: {\n                  backgroundColor: active.color,\n                  height: '10px',\n                  width: '10px',\n                  borderRadius: '50%',\n                  display: 'inline-block',\n                  marginRight: '5px'\n                }\n              }),\n              active.label &&\n                  h(\n                    'span',\n                    {\n                      style: {\n                        marginRight: '5px'\n                      }\n                    },\n                    active.label + ':'\n                  ),\n              h('span', active.value)\n            ]); }\n          )\n        ]\n      );\n\n    return h(\n      'div',\n      {\n        class: 'la-tooltip',\n        style: {\n          position: 'absolute',\n          top: 0,\n          transform: (\"translate(\" + (this.left) + \"px, \" + (this.top) + \"px)\"),\n          transition: this.trans,\n          opacity: Number(this.show)\n        }\n      },\n      [tooltip]\n    )\n  }\n}\n\nvar Legend = {\n  name: 'LaLegend',\n\n  mixins: [widget],\n\n  props: {\n    selectable: Boolean,\n\n    /**\n     * ^(top|bottom|left|right)(-(start|center|end))?$\n     */\n    placement: {\n      type: String,\n      default: 'bottom'\n    },\n\n    color: String\n  },\n\n  preload: function preload(ref) {\n    var data = ref.data;\n    var parent = ref.parent;\n\n    var placement = data.placement; if ( placement === void 0 ) placement = 'bottom';\n    var space = [0, 0, 0, 0];\n\n    switch (placement.match(/^(\\w+)-?/)[1]) {\n      case 'bottom':\n        space[2] = 50;\n        break\n      case 'top':\n        space[0] = 50;\n        break\n      case 'left':\n        space[3] = 100;\n        break\n      case 'right':\n        space[1] = 100;\n        break\n      default:\n        break\n    }\n\n    parent.addSpace(space);\n  },\n\n  computed: {\n    curColor: function curColor() {\n      return this.color || this.Plane.textColor\n    },\n\n    position: function position() {\n      return this.placement.match(/^(\\w+)(-(\\w+))?$/)[1]\n    },\n\n    align: function align() {\n      return this.placement.match(/^(\\w+)(-(\\w+))?$/)[3]\n    },\n\n    pos: function pos() {\n      var ref = this;\n      var position = ref.position;\n      var align = ref.align;\n      var pos = {};\n\n      if (position === 'top' || position === 'bottom') {\n        switch (align) {\n          case 'start':\n            pos.left = 0;\n            break\n          case 'end':\n            pos.right = 0;\n            break\n          default:\n            pos.left = '50%';\n            pos.transform = 'translateX(-50%)';\n            break\n        }\n        if (position === 'top') {\n          pos.top = 0;\n        } else {\n          pos.bottom = 0;\n        }\n      } else {\n        switch (align) {\n          case 'start':\n            pos.top = 0;\n            break\n          case 'end':\n            pos.bottom = 0;\n            break\n          default:\n            pos.top = '50%';\n            pos.transform = 'translateY(-50%)';\n            break\n        }\n        if (position === 'left') {\n          pos.left = 0;\n        } else {\n          pos.right = 0;\n        }\n      }\n\n      return pos\n    }\n  },\n\n  created: function created() {\n    this.$set(this.store, 'hidden', []);\n  },\n\n  render: function render(h) {\n    var ref = this;\n    var curColor = ref.curColor;\n    var pos = ref.pos;\n    var position = ref.position;\n    var selectable = ref.selectable;\n    var store = ref.store;\n    var hidden = store.hidden;\n    var slot = this.$scopedSlots.default;\n\n    return h(\n      'div',\n      {\n        class: 'la-legend',\n        style: extend(\n          {\n            position: 'absolute'\n          },\n          pos\n        )\n      },\n      Object.keys(store.props).map(function (id) { return h(\n          'div',\n          {\n            style: {\n              display:\n                position === 'left' || position === 'right' ?\n                  'block' :\n                  'inline-block',\n              marginRight: '10px',\n              marginLeft: '5px',\n              color: curColor,\n              cursor: selectable ? 'pointer' : 'nromal'\n            },\n            on: {\n              click: function () {\n                if (!selectable) {\n                  return\n                }\n                id = Number(id);\n                var index = hidden.indexOf(id);\n\n                if (index < 0) {\n                  hidden.push(id);\n                } else {\n                  hidden.splice(index, 1);\n                }\n              }\n            }\n          },\n          slot ?\n            slot({\n              color: store.colors[id],\n              label: store.labels[id],\n              prop: store.props[id]\n            }) :\n            [\n              h('span', {\n                style: {\n                  backgroundColor: store.colors[id],\n                  height: '10px',\n                  width: '10px',\n                  borderRadius: '50%',\n                  display: 'inline-block',\n                  marginRight: '5px'\n                }\n              }),\n              h(\n                'span',\n                {\n                  style:\n                      hidden.indexOf(Number(id)) > -1 ?\n                        {\n                          textDecoration: 'line-through'\n                        } :\n                        {}\n                },\n                store.labels[id]\n              )\n            ]\n        ); }\n      )\n    )\n  }\n}\n\nfunction Laue(Vue) {\n  [\n    Cartesian,\n    Polar,\n    Line,\n    Area,\n    Bar,\n    Pie,\n    XAxis,\n    YAxis,\n    XAxisInverse,\n    YAxisInverse,\n    Tooltip,\n    Legend,\n    YMarker,\n    YRegion\n  ].forEach(function (c) {\n    Vue.component(c.name, c);\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGF1ZS9kaXN0L2xhdWUuanM/YmYxYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQyxpRUFBaUUsT0FBTztBQUN4RTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE9BQU87QUFDdEIsaUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDLG1FQUFtRSxPQUFPO0FBQzFFLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFD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QUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsaUNBQWlDOztBQUUzRCxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsMkNBQTJDO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYSxFQUFFO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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Q0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QscUJBQXFCLEVBQUU7QUFDN0UsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsZUFBZSx1QkFBdUIsY0FBYyxFQUFFO0FBQ2hHLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsRUFBRTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFcUkiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGF1ZS9kaXN0L2xhdWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIExhdWUgdjAuMi4xXG4gKiBodHRwczovL2xhdWUuanMub3JnXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IHFpbmd3ZWktbGlcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cbmZ1bmN0aW9uIGlzRm4obykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdmdW5jdGlvbidcbn1cblxuZnVuY3Rpb24gaXNBcnIobykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvKVxufVxuXG5mdW5jdGlvbiBpc05pbChvKSB7XG4gIHJldHVybiBvID09PSBudWxsIHx8IG8gPT09IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc051bShuKSB7XG4gIHJldHVybiAhaXNOYU4obilcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKHRvLCBfZnJvbSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cblxuICByZXR1cm4gdG9cbn1cblxuZnVuY3Rpb24gbm9OaWxJbkFycmF5KGFycikge1xuICByZXR1cm4gIWFyci5zb21lKGlzTmlsKVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XG4gIGlmICggZGVsYXkgPT09IHZvaWQgMCApIGRlbGF5ID0gMjA7XG5cbiAgdmFyIGlkO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzQXJyYXkgPSBBcnJheShpKTtcbiAgICB3aGlsZSAoIGktLSApIGFyZ3NBcnJheVtpXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgaWQgPSBzZXRUaW1lb3V0LmFwcGx5KHZvaWQgMCwgWyBmbiwgZGVsYXkgXS5jb25jYXQoIGFyZ3NBcnJheSApKTtcbiAgfVxufVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0YW50KCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXROb25lKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDEpKSB7IHJldHVybjsgfVxuICBmb3IgKHZhciBpID0gMSwgaiwgczAsIHMxID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMxLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHMwID0gczEsIHMxID0gc2VyaWVzW29yZGVyW2ldXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBzMVtqXVsxXSArPSBzMVtqXVswXSA9IGlzTmFOKHMwW2pdWzFdKSA/IHMwW2pdWzBdIDogczBbal1bMV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9yZGVyTm9uZShzZXJpZXMpIHtcbiAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoLCBvID0gbmV3IEFycmF5KG4pO1xuICB3aGlsZSAoLS1uID49IDApIHsgb1tuXSA9IG47IH1cbiAgcmV0dXJuIG87XG59XG5cbmZ1bmN0aW9uIHN0YWNrVmFsdWUoZCwga2V5KSB7XG4gIHJldHVybiBkW2tleV07XG59XG5cbmZ1bmN0aW9uIHN0YWNrKCkge1xuICB2YXIga2V5cyA9IGNvbnN0YW50KFtdKSxcbiAgICAgIG9yZGVyID0gb3JkZXJOb25lLFxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0Tm9uZSxcbiAgICAgIHZhbHVlID0gc3RhY2tWYWx1ZTtcblxuICBmdW5jdGlvbiBzdGFjayhkYXRhKSB7XG4gICAgdmFyIGt6ID0ga2V5cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBpLFxuICAgICAgICBtID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIG4gPSBrei5sZW5ndGgsXG4gICAgICAgIHN6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBvejtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGZvciAodmFyIGtpID0ga3pbaV0sIHNpID0gc3pbaV0gPSBuZXcgQXJyYXkobSksIGogPSAwLCBzaWo7IGogPCBtOyArK2opIHtcbiAgICAgICAgc2lbal0gPSBzaWogPSBbMCwgK3ZhbHVlKGRhdGFbal0sIGtpLCBqLCBkYXRhKV07XG4gICAgICAgIHNpai5kYXRhID0gZGF0YVtqXTtcbiAgICAgIH1cbiAgICAgIHNpLmtleSA9IGtpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG96ID0gb3JkZXIoc3opOyBpIDwgbjsgKytpKSB7XG4gICAgICBzeltveltpXV0uaW5kZXggPSBpO1xuICAgIH1cblxuICAgIG9mZnNldChzeiwgb3opO1xuICAgIHJldHVybiBzejtcbiAgfVxuXG4gIHN0YWNrLmtleXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoa2V5cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoc2xpY2UuY2FsbChfKSksIHN0YWNrKSA6IGtleXM7XG4gIH07XG5cbiAgc3RhY2sudmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgc3RhY2spIDogdmFsdWU7XG4gIH07XG5cbiAgc3RhY2sub3JkZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3JkZXIgPSBfID09IG51bGwgPyBvcmRlck5vbmUgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpLCBzdGFjaykgOiBvcmRlcjtcbiAgfTtcblxuICBzdGFjay5vZmZzZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob2Zmc2V0ID0gXyA9PSBudWxsID8gb2Zmc2V0Tm9uZSA6IF8sIHN0YWNrKSA6IG9mZnNldDtcbiAgfTtcblxuICByZXR1cm4gc3RhY2s7XG59XG5cbmZ1bmN0aW9uIHN0YWNrT2Zmc2V0RGl2ZXJnaW5nKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDEpKSB7IHJldHVybjsgfVxuICBmb3IgKHZhciBpLCBqID0gMCwgZCwgZHksIHlwLCB5biwgbiwgbSA9IHNlcmllc1tvcmRlclswXV0ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh5cCA9IHluID0gMCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgoZHkgPSAoZCA9IHNlcmllc1tvcmRlcltpXV1bal0pWzFdIC0gZFswXSkgPj0gMCkge1xuICAgICAgICBkWzBdID0geXAsIGRbMV0gPSB5cCArPSBkeTtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPCAwKSB7XG4gICAgICAgIGRbMV0gPSB5biwgZFswXSA9IHluICs9IGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFswXSA9IHlwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgcGxhbmUgPSB7XG4gIHByb3BzOiB7XG4gICAgZGF0YToge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfVxuICAgIH0sXG5cbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDMwMFxuICAgIH0sXG5cbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogNjAwXG4gICAgfSxcblxuICAgIGF1dG9yZXNpemU6IEJvb2xlYW4sXG5cbiAgICBwYWRkaW5nOiB7XG4gICAgICBkZWZhdWx0OiA4LFxuICAgICAgdHlwZTogW051bWJlciwgQXJyYXldXG4gICAgfSxcblxuICAgIHN0YWNrZWQ6IEJvb2xlYW4sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBjb2xvcnMgaXMgXCJ3YWxkZW5cIiBmcm9tIEVDaGFydHNcbiAgICAgKiBAc2VlIGh0dHA6Ly9lY2hhcnRzLmJhaWR1LmNvbS90aGVtZS1idWlsZGVyL1xuICAgICAqL1xuICAgIGNvbG9yczoge1xuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAnIzNmYjFlMycsXG4gICAgICAgICcjNmJlNmMxJyxcbiAgICAgICAgJyM2MjZjOTEnLFxuICAgICAgICAnI2EwYTdlNicsXG4gICAgICAgICcjYzRlYmFkJyxcbiAgICAgICAgJyM5NmRlZTgnXG4gICAgICBdOyB9LFxuICAgICAgdHlwZTogW0FycmF5LCBGdW5jdGlvbl1cbiAgICB9LFxuXG4gICAgdGV4dENvbG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnIzk5OSdcbiAgICB9XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIHBhZGRpbmcgPSByZWYucGFkZGluZztcbiAgICAgIHZhciBzcGFjZSA9IHJlZi5zcGFjZTtcbiAgICAgIHZhciBwYWQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBpc0FycihwYWRkaW5nKSA/IHBhZGRpbmdbaV0gfHwgMCA6IHBhZGRpbmc7XG4gICAgICAgIHZhciBzID0gc3BhY2VbaV07XG4gICAgICAgIHBhZFtpXSA9IGlzRm4ocCkgPyBwKHMpIDogcyArIHA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYWRcbiAgICB9LFxuXG4gICAgdmlld1dpZHRoOiBmdW5jdGlvbiB2aWV3V2lkdGgoKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnRXaWR0aCA9IHJlZi5wYXJlbnRXaWR0aDtcbiAgICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICAgIHJldHVybiBpc05pbChwYXJlbnRXaWR0aCkgPyB3aWR0aCA6IHBhcmVudFdpZHRoXG4gICAgfSxcblxuICAgIGNhbnZhczogZnVuY3Rpb24gY2FudmFzKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgdmlld1dpZHRoID0gcmVmLnZpZXdXaWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSByZWYuaGVpZ2h0O1xuICAgICAgdmFyIG9mZnNldCA9IHJlZi5vZmZzZXQ7XG4gICAgICB2YXIgeDAgPSBvZmZzZXRbM107XG4gICAgICB2YXIgeTAgPSBvZmZzZXRbMF07XG4gICAgICB2YXIgeTEgPSBoZWlnaHQgLSBvZmZzZXRbMl07XG4gICAgICB2YXIgeDEgPSB2aWV3V2lkdGggLSBvZmZzZXRbMV07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgwOiB4MCxcbiAgICAgICAgeTA6IHkwLFxuICAgICAgICB3aWR0aDogeDEgLSB4MCxcbiAgICAgICAgaGVpZ2h0OiB5MSAtIHkwLFxuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjdXJEYXRhOiBmdW5jdGlvbiBjdXJEYXRhKCkge1xuICAgICAgcmV0dXJuIHN0YWNrKClcbiAgICAgICAgLmtleXModGhpcy5wcm9wcylcbiAgICAgICAgLm9mZnNldCh0aGlzLnN0YWNrZWQgPyBzdGFja09mZnNldERpdmVyZ2luZyA6IG5vb3ApKHRoaXMuZGF0YSlcbiAgICB9XG4gIH0sXG5cbiAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgUGxhbmU6IHRoaXNcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGdlbkNvbG9yOiBmdW5jdGlvbiBnZW5Db2xvcihpbmRleCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgY29sb3JzID0gcmVmLmNvbG9ycztcblxuICAgICAgaWYgKGlzQXJyKGNvbG9ycykpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yc1tpbmRleCAlIGNvbG9ycy5sZW5ndGhdXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xvcnMoaW5kZXgpXG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHdpZHRoID0gcmVmLndpZHRoO1xuICAgICAgdGhpcy5wYXJlbnRXaWR0aCA9IHdpZHRoO1xuICAgIH0sXG5cbiAgICBhZGRTcGFjZTogZnVuY3Rpb24gYWRkU3BhY2Uoc3BhY2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgaWYgKCBzcGFjZSA9PT0gdm9pZCAwICkgc3BhY2UgPSBbXTtcblxuICAgICAgc3BhY2UuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgIHRoaXMkMS5zcGFjZVtpXSA9IE1hdGgubWF4KHZhbCwgdGhpcyQxLnNwYWNlW2ldIHx8IDApO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgc3BhY2U6IFswLCAwLCAwLCAwXSxcbiAgICBwYXJlbnRXaWR0aDogbnVsbCxcbiAgICBwcm9wczogW10sXG4gICAgc3RvcmU6IHt9XG4gIH0pOyB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgaWYgKHRoaXMuYXV0b3Jlc2l6ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZGVib3VuY2UodGhpcy5yZXNpemUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGUxMCA9IE1hdGguc3FydCg1MCksXG4gICAgZTUgPSBNYXRoLnNxcnQoMTApLFxuICAgIGUyID0gTWF0aC5zcXJ0KDIpO1xuXG5mdW5jdGlvbiB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAwID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcDApIC8gTWF0aC5MTjEwKSksXG4gICAgICBlcnJvciA9IHN0ZXAwIC8gc3RlcDE7XG4gIGlmIChlcnJvciA+PSBlMTApIHsgc3RlcDEgKj0gMTA7IH1cbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTUpIHsgc3RlcDEgKj0gNTsgfVxuICBlbHNlIGlmIChlcnJvciA+PSBlMikgeyBzdGVwMSAqPSAyOyB9XG4gIHJldHVybiBzdG9wIDwgc3RhcnQgPyAtc3RlcDEgOiBzdGVwMTtcbn1cblxuZnVuY3Rpb24gaW50KHN0cikge1xuICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMClcbn1cblxuLyoqXG4gKiBSZXR1cm5zIG5pY2sgdGlja3NcbiAqL1xuZnVuY3Rpb24gZ2VuVGlja3MobWluLCBtYXgsIGNvdW50KSB7XG4gIHZhciBhc3NpZ247XG5cbiAgaWYgKG1heCA8IG1pbikge1xuICAgIChhc3NpZ24gPSBbbWF4LCBtaW5dLCBtaW4gPSBhc3NpZ25bMF0sIG1heCA9IGFzc2lnblsxXSk7XG4gIH1cblxuICBpZiAobWluID09PSAwICYmIG1heCA9PT0gMCkge1xuICAgIHJldHVybiBbMF1cbiAgfVxuXG4gIHZhciBzdGVwID0gdGlja1N0ZXAobWluLCBtYXgsIGNvdW50KTtcbiAgdmFyIGZpcnN0ID0gTWF0aC5mbG9vcihtaW4gLyBzdGVwKSAqIHN0ZXA7XG4gIHZhciB0aWNrcyQkMSA9IFtmaXJzdF07XG4gIHZhciBjdXIgPSBmaXJzdDtcblxuICB3aGlsZSAoY3VyIDwgbWF4KSB7XG4gICAgY3VyICs9IHN0ZXA7XG4gICAgdGlja3MkJDEucHVzaChjdXIpO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKG1pbiAtIHRpY2tzJCQxWzFdKSA8IHN0ZXApIHtcbiAgICB0aWNrcyQkMS5zaGlmdCgpO1xuICAgIHRpY2tzJCQxWzBdID0gbWluO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKG1heCAtIHRpY2tzJCQxW3RpY2tzJCQxLmxlbmd0aCAtIDJdKSA8IHN0ZXApIHtcbiAgICB0aWNrcyQkMS5wb3AoKTtcbiAgICB0aWNrcyQkMVt0aWNrcyQkMS5sZW5ndGggLSAxXSA9IG1heDtcbiAgfVxuXG4gIHJldHVybiB0aWNrcyQkMVxufVxuXG5mdW5jdGlvbiBnZW5FeGFjdE5iVGlja3MobWluLCBtYXgsIGNvdW50KSB7XG4gIHZhciBkaWZmID0gbWF4IC0gbWluO1xuICB2YXIgc3RlcCA9IGRpZmYgLyAoY291bnQgLSAxKTtcbiAgdmFyIHRpY2tzJCQxID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgdGlja3MkJDEucHVzaChpICogc3RlcCk7XG4gIH1cblxuICB0aWNrcyQkMS5wdXNoKG1heCk7XG5cbiAgcmV0dXJuIHRpY2tzJCQxXG59XG5cbmZ1bmN0aW9uIGJvdW5kKGRhdGEsIHR5cGUsIGtleSkge1xuICByZXR1cm4gTWF0aFt0eXBlXS5hcHBseShcbiAgICBNYXRoLCBkYXRhLm1hcChmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBNYXRoW3R5cGVdLmFwcGx5KE1hdGgsIGFyci5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW1ba2V5XTsgfSkuZmlsdGVyKGlzTnVtKSk7IH0pXG4gIClcbn1cblxudmFyIENhcnRlc2lhbiA9IHtcbiAgbmFtZTogJ0xhQ2FydGVzaWFuJyxcblxuICBtaXhpbnM6IFtwbGFuZV0sXG5cbiAgcHJvcHM6IHtcbiAgICBib3VuZDoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfVxuICAgIH0sXG5cbiAgICBuYXJyb3c6IFtCb29sZWFuLCBOdW1iZXIsIEZ1bmN0aW9uXSxcblxuICAgIGRpc3RhbmNlOiB7XG4gICAgICBkZWZhdWx0OiAwLFxuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfVxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgaGlnaDogZnVuY3Rpb24gaGlnaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kKHRoaXMuYm91bmRbMV0sICdtYXgnKVxuICAgIH0sXG5cbiAgICBsb3c6IGZ1bmN0aW9uIGxvdygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kKHRoaXMuYm91bmRbMF0sICdtaW4nKVxuICAgIH0sXG5cbiAgICBsZW46IGZ1bmN0aW9uIGxlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoXG4gICAgfSxcblxuICAgIHRlbXBYUmF0aW86IGZ1bmN0aW9uIHRlbXBYUmF0aW8oKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBsZW4gPSByZWYubGVuO1xuICAgICAgcmV0dXJuIGxlbiA8PSAxID8gMCA6IHRoaXMuY2FudmFzLndpZHRoIC8gKGxlbiAtIDEpXG4gICAgfSxcblxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgbmFycm93ID0gcmVmLm5hcnJvdztcbiAgICAgIHZhciB0ZW1wWFJhdGlvID0gcmVmLnRlbXBYUmF0aW87XG5cbiAgICAgIGlmIChpc0ZuKG5hcnJvdykpIHtcbiAgICAgICAgcmV0dXJuIG5hcnJvdyh0ZW1wWFJhdGlvKVxuICAgICAgfVxuICAgICAgaWYgKG5hcnJvdyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdGVtcFhSYXRpbyAvIDJcbiAgICAgIH1cbiAgICAgIHJldHVybiBOdW1iZXIobmFycm93KVxuICAgIH0sXG5cbiAgICB4UmF0aW86IGZ1bmN0aW9uIHhSYXRpbygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlbXBYUmF0aW8gP1xuICAgICAgICB0aGlzLnRlbXBYUmF0aW8gLSAyICogdGhpcy5nYXAgLyAodGhpcy5sZW4gLSAxKSA6XG4gICAgICAgIDBcbiAgICB9LFxuXG4gICAgeVJhdGlvOiBmdW5jdGlvbiB5UmF0aW8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0IC8gKHRoaXMuaGlnaCAtIHRoaXMubG93IHx8IDEpXG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBnZXRCb3VuZDogZnVuY3Rpb24gZ2V0Qm91bmQodmFsLCB0eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgfVxuXG4gICAgICB2YXIgaXNNaW4gPSB0eXBlID09PSAnbWluJztcbiAgICAgIHZhciByZXN1bHQgPSBib3VuZCh0aGlzLmN1ckRhdGEsIHR5cGUsIGlzTWluID8gMCA6IDEpO1xuXG4gICAgICBpZiAoaXNNaW4gJiYgcmVzdWx0ID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJvdW5kKHRoaXMuY3VyRGF0YSwgJ21pbicsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGbih2YWwpKSB7XG4gICAgICAgIHJldHVybiB2YWwocmVzdWx0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdG9kbyBOZWVkIHRvIG9wdGltaXplLiBUaGUgUHJvcHMgY2hhbmdlcyB3aWxsIGNhbGwgdXBkYXRlIGV2ZW4gaWYgaXQgZG9lcyBub3QgbmVlZC5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9pc3N1ZXMvNTcyN1xuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIHZpZXdXaWR0aCA9IHJlZi52aWV3V2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgdmFyIGF1dG9yZXNpemUgPSByZWYuYXV0b3Jlc2l6ZTtcbiAgICB2YXIgc2xvdHMgPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogUmVzZXQgc25hcFxuICAgICAqL1xuICAgIHRoaXMuc25hcCA9IHt9O1xuXG4gICAgdmFyIHByb3BzID0gW107XG4gICAgdmFyIGNhcnRlc2lhbnMgPSBbXTtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIHZhciB3aWRnZXRzID0gW107XG4gICAgdmFyIG90aGVycyA9IFtdO1xuXG4gICAgc2xvdHMuZm9yRWFjaChmdW5jdGlvbiAoc2xvdCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBzbG90LmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3RoZXJzLnB1c2goc2xvdCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIHNlYWxlZCA9IG9wdGlvbnMuQ3Rvci5zZWFsZWRPcHRpb25zO1xuICAgICAgaWYgKCFzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgcHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzRGF0YS5wcm9wO1xuXG4gICAgICBzd2l0Y2ggKHNlYWxlZC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NhcnRlc2lhbic6XG4gICAgICAgICAgaWYgKHByb3AgJiYgcHJvcHMuaW5kZXhPZihwcm9wKSA8IDApIHtcbiAgICAgICAgICAgIHByb3BzLnB1c2gocHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNsb3QuaW5kZXggPSBjYXJ0ZXNpYW5zLmxlbmd0aDtcbiAgICAgICAgICBjYXJ0ZXNpYW5zLnB1c2goc2xvdCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICB0aGlzJDEuYWRkU3BhY2Uoc2VhbGVkLnNwYWNlKTtcbiAgICAgICAgICBvYmplY3RzLnB1c2goc2xvdCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnd2lkZ2V0JzpcbiAgICAgICAgICB3aWRnZXRzLnB1c2goc2xvdCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHNlYWxlZC5wcmVsb2FkKSB7XG4gICAgICAgIHNlYWxlZC5wcmVsb2FkKHtkYXRhOiBwcm9wc0RhdGEsIHBhcmVudDogdGhpcyQxLCBpbmRleDogc2xvdC5pbmRleH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuXG4gICAgcmV0dXJuIGgoXG4gICAgICAnZGl2JyxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICB3aWR0aDogYXV0b3Jlc2l6ZSA/ICcxMDAlJyA6IHZpZXdXaWR0aCArICdweCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgaChcbiAgICAgICAgICAnc3ZnJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICB3aWR0aDogdmlld1dpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgdmlld0JveDogKFwiMCAwIFwiICsgdmlld1dpZHRoICsgXCIgXCIgKyBoZWlnaHQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbb3RoZXJzLCBjYXJ0ZXNpYW5zLCBvYmplY3RzXVxuICAgICAgICApLFxuICAgICAgICB3aWRnZXRzXG4gICAgICBdXG4gICAgKVxuICB9XG59XG5cbnZhciBQb2xhciA9IHtcbiAgbmFtZTogJ0xhUG9sYXInLFxuXG4gIG1peGluczogW3BsYW5lXSxcblxuICBwcm9wczoge1xuICAgIGZpbGxDb250YWluZXI6IEJvb2xlYW5cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIG1pbjogZnVuY3Rpb24gbWluKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMudmlld1dpZHRoLCB0aGlzLmhlaWdodClcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciB2aWV3V2lkdGggPSByZWYudmlld1dpZHRoO1xuICAgIHZhciBoZWlnaHQgPSByZWYuaGVpZ2h0O1xuICAgIHZhciBhdXRvcmVzaXplID0gcmVmLmF1dG9yZXNpemU7XG4gICAgdmFyIHNsb3RzID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHNuYXBcbiAgICAgKi9cbiAgICB0aGlzLnNuYXAgPSB7fTtcblxuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIHZhciBwb2xhcnMgPSBbXTtcbiAgICB2YXIgd2lkZ2V0cyA9IFtdO1xuICAgIHZhciBvdGhlcnMgPSBbXTtcblxuICAgIHNsb3RzLmZvckVhY2goZnVuY3Rpb24gKHNsb3QpIHtcbiAgICAgIHZhciBvcHRpb25zID0gc2xvdC5jb21wb25lbnRPcHRpb25zO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG90aGVycy5wdXNoKHNsb3QpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBzZWFsZWQgPSBvcHRpb25zLkN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgICAgIGlmICghc2VhbGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIHByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICAgICAgdmFyIHByb3AgPSBwcm9wc0RhdGEucHJvcDtcblxuICAgICAgc3dpdGNoIChzZWFsZWQudHlwZSkge1xuICAgICAgICBjYXNlICdwb2xhcic6XG4gICAgICAgICAgaWYgKHByb3AgJiYgcHJvcHMuaW5kZXhPZihwcm9wKSA8IDApIHtcbiAgICAgICAgICAgIHByb3BzLnB1c2gocHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNsb3QuaW5kZXggPSBwb2xhcnMubGVuZ3RoO1xuICAgICAgICAgIHBvbGFycy5wdXNoKHNsb3QpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3dpZGdldCc6XG4gICAgICAgICAgd2lkZ2V0cy5wdXNoKHNsb3QpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcblxuICAgIHJldHVybiBoKFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgd2lkdGg6IGF1dG9yZXNpemUgPyAnMTAwJScgOiB2aWV3V2lkdGggKyAncHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIGgoXG4gICAgICAgICAgJ3N2ZycsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuZmlsbENvbnRhaW5lciA/ICcxMDAlJyA6IHZpZXdXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmZpbGxDb250YWluZXIgPyAnMTAwJScgOiBoZWlnaHQsXG4gICAgICAgICAgICAgIHZpZXdCb3g6IHRoaXMuZmlsbENvbnRhaW5lciA/IChcIjAgMCBcIiArICh0aGlzLm1pbikgKyBcIiBcIiArICh0aGlzLm1pbikpIDogKFwiMCAwIFwiICsgdmlld1dpZHRoICsgXCIgXCIgKyBoZWlnaHQpLFxuICAgICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pbllNaW4nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbb3RoZXJzLCBwb2xhcnNdXG4gICAgICAgICksXG4gICAgICAgIHdpZGdldHNcbiAgICAgIF1cbiAgICApXG4gIH1cbn1cblxudmFyIGJhc2ljID0ge1xuICBpbmplY3Q6IFsnUGxhbmUnXSxcblxuICBjb21wdXRlZDoge1xuICAgIHN0b3JlOiBmdW5jdGlvbiBzdG9yZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLlBsYW5lLnN0b3JlXG4gICAgfVxuICB9XG59XG5cbnZhciB2YWx1ZXMgPSB7XG4gIHByb3BzOiB7XG4gICAgcHJvcDogU3RyaW5nXG4gIH0sXG5cbiAgbWl4aW5zOiBbYmFzaWNdLFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgcmF3czogZnVuY3Rpb24gcmF3cygpIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIHByb3AgPSByZWYucHJvcDtcbiAgICAgIHZhciBQbGFuZSA9IHJlZi5QbGFuZTtcblxuICAgICAgcmV0dXJuIHByb3AgPyBQbGFuZS5kYXRhLm1hcChmdW5jdGlvbiAobykgeyByZXR1cm4gb1twcm9wXTsgfSkgOiBudWxsXG4gICAgfSxcblxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgcHJvcCA9IHJlZi5wcm9wO1xuICAgICAgdmFyIFBsYW5lID0gcmVmLlBsYW5lO1xuXG4gICAgICByZXR1cm4gUGxhbmUuY3VyRGF0YS5maWx0ZXIoZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLmtleSA9PT0gcHJvcDsgfSlbMF0gfHwgW11cbiAgICB9XG4gIH1cbn1cblxudmFyIGFuaW1hdGUgPSB7XG4gIHByb3BzOiB7XG4gICAgYW5pbWF0ZWQ6IEJvb2xlYW4sXG5cbiAgICBhbmltYXRpb25EdXJhdGlvbjoge1xuICAgICAgZGVmYXVsdDogMSxcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH0sXG5cbiAgICBhbmltYXRpb25FZmZlY3Q6IHtcbiAgICAgIGRlZmF1bHQ6ICdlYXNlJyxcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICB0cmFuc2l0aW9uOiBTdHJpbmdcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHRyYW5zOiBmdW5jdGlvbiB0cmFucygpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbiB8fFxuICAgICAgICAodGhpcy5hbmltYXRlZCA/XG4gICAgICAgICAgKFwiYWxsIFwiICsgKHRoaXMuYW5pbWF0aW9uRHVyYXRpb24pICsgXCJzIFwiICsgKHRoaXMuYW5pbWF0aW9uRWZmZWN0KSkgOlxuICAgICAgICAgICdub25lJylcbiAgICAgIClcbiAgICB9XG4gIH1cbn1cblxudmFyIGNoYXJ0ID0ge1xuICBtaXhpbnM6IFt2YWx1ZXMsIGFuaW1hdGVdLFxuXG4gIHByb3BzOiB7XG4gICAgcG9pbnRzOiBBcnJheSxcblxuICAgIGNvbG9yOiBTdHJpbmcsXG5cbiAgICBsYWJlbDogU3RyaW5nLFxuXG4gICAgc2hvd1ZhbHVlOiBCb29sZWFuXG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBpZDogZnVuY3Rpb24gaWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kdm5vZGUuaW5kZXhcbiAgICB9LFxuXG4gICAgY3VyQ29sb3I6IGZ1bmN0aW9uIGN1ckNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29sb3IgfHwgdGhpcy5QbGFuZS5nZW5Db2xvcih0aGlzLmlkKVxuICAgIH0sXG5cbiAgICBhY3RpdmVkOiBmdW5jdGlvbiBhY3RpdmVkKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXMuc3RvcmU7XG4gICAgICB2YXIgaGlkZGVuID0gcmVmLmhpZGRlbjtcblxuICAgICAgaWYgKCFpc0FycihoaWRkZW4pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoaWRkZW4uaW5kZXhPZih0aGlzLmlkKSA8IDBcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICAnc3RvcmUuYWN0aXZlZEluZGV4JzogZnVuY3Rpb24gc3RvcmVfYWN0aXZlZEluZGV4KGluZGV4KSB7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBzdG9yZSA9IHJlZi5zdG9yZTtcblxuICAgICAgc3RvcmUuYWN0aXZlZFBvaW50ID0gW10uY29uY2F0KHN0b3JlLmFjdGl2ZWRQb2ludCk7XG5cbiAgICAgIHRoaXMuJHNldChzdG9yZS5hY3RpdmVkUG9pbnQsIHRoaXMuaWQsIHtcbiAgICAgICAgY29sb3I6IHRoaXMuY3VyQ29sb3IsXG4gICAgICAgIHZhbHVlOiB0aGlzLnJhd3NbaW5kZXhdLFxuICAgICAgICBsYWJlbDogdGhpcy5sYWJlbFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGN1ckNvbG9yOiB7XG4gICAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHZhbCkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIHN0b3JlID0gcmVmLnN0b3JlO1xuXG4gICAgICAgIHN0b3JlLmNvbG9ycyA9IHN0b3JlLmNvbG9ycyB8fCB7fTtcbiAgICAgICAgdGhpcy4kc2V0KHN0b3JlLmNvbG9ycywgdGhpcy5pZCwgdmFsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGFiZWw6IHtcbiAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIodmFsKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RvcmUgPSByZWYuc3RvcmU7XG5cbiAgICAgICAgc3RvcmUubGFiZWxzID0gc3RvcmUubGFiZWxzIHx8IHt9O1xuICAgICAgICB0aGlzLiRzZXQoc3RvcmUubGFiZWxzLCB0aGlzLmlkLCB2YWwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcih2YWwpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdG9yZSA9IHJlZi5zdG9yZTtcblxuICAgICAgICBzdG9yZS5wcm9wcyA9IHN0b3JlLnByb3BzIHx8IHt9O1xuXG4gICAgICAgIGlmICghaXNOaWwodGhpcy5pZCkpIHtcbiAgICAgICAgICB0aGlzLiRzZXQoc3RvcmUucHJvcHMsIHRoaXMuaWQsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGNhcnRlc2lhbiA9IHtcbiAgbWl4aW5zOiBbY2hhcnRdLFxuXG4gIHR5cGU6ICdjYXJ0ZXNpYW4nLFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgY3VyUG9pbnRzOiBmdW5jdGlvbiBjdXJQb2ludHMoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucG9pbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50c1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gdGhpcy5QbGFuZTtcbiAgICAgIHZhciBnYXAgPSByZWYuZ2FwO1xuICAgICAgdmFyIHhSYXRpbyA9IHJlZi54UmF0aW87XG4gICAgICB2YXIgeVJhdGlvID0gcmVmLnlSYXRpbztcbiAgICAgIHZhciBsb3cgPSByZWYubG93O1xuICAgICAgdmFyIGNhbnZhcyA9IHJlZi5jYW52YXM7XG4gICAgICB2YXIgeDAgPSBjYW52YXMueDA7XG4gICAgICB2YXIgeTEgPSBjYW52YXMueTE7XG5cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHZhciBhc3NpZ247XG5cbiAgICAgICAgaWYgKGlzTmlsKHRoaXMkMS5yYXdzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBbbnVsbF1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydCA9IHZhbHVlWzBdO1xuICAgICAgICB2YXIgZW5kID0gdmFsdWVbMV07XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgIChhc3NpZ24gPSB2YWx1ZSwgZW5kID0gYXNzaWduWzBdLCBzdGFydCA9IGFzc2lnblsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IE1hdGgubWF4KGxvdywgc3RhcnQpO1xuXG4gICAgICAgIHZhciB5ID0gaXNOYU4oZW5kKSA/IG51bGwgOiB5MSAtIChlbmQgLSBsb3cpICogeVJhdGlvO1xuICAgICAgICB2YXIgeTAgPSBpc05hTihzdGFydCkgPyBudWxsIDogeTEgLSAoc3RhcnQgLSBsb3cpICogeVJhdGlvO1xuICAgICAgICB2YXIgeCA9IHgwICsgeFJhdGlvICogaSArIGdhcDtcblxuICAgICAgICByZXR1cm4gW3gsIHksIHkwXVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgcG9pbnRTbG90OiBmdW5jdGlvbiBwb2ludFNsb3QoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIHNjb3BlZCA9IHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQ7XG4gICAgICB2YXIgYWN0aXZlZCA9IHRoaXMuc3RvcmUuYWN0aXZlZEluZGV4O1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBzY29wZWQgJiZcbiAgICAgICAgdGhpcy5jdXJQb2ludHMubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBzY29wZWQoe1xuICAgICAgICAgICAgeDogcFswXSxcbiAgICAgICAgICAgIHk6IHBbMV0sXG4gICAgICAgICAgICB2YWx1ZTogdGhpcyQxLnJhd3NbaV0sXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIGFjdGl2ZWQ6IGFjdGl2ZWQgPT09IGksXG4gICAgICAgICAgICBjb2xvcjogdGhpcyQxLmN1ckNvbG9yLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcyQxLnRyYW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IH1cbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gUGF0aCgpIHtcbiAgdGhpcy5feDAgPSB0aGlzLl95MCA9IC8vIHN0YXJ0IG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl8gPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gbmV3IFBhdGg7XG59XG5cblBhdGgucHJvdG90eXBlID0gcGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgIH1cbiAgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIlFcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiQ1wiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAoK3gyKSArIFwiLFwiICsgKCt5MikgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBhcmNUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHIpIHtcbiAgICB4MSA9ICt4MSwgeTEgPSAreTEsIHgyID0gK3gyLCB5MiA9ICt5MiwgciA9ICtyO1xuICAgIHZhciB4MCA9IHRoaXMuX3gxLFxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxuICAgICAgICB4MjEgPSB4MiAtIHgxLFxuICAgICAgICB5MjEgPSB5MiAtIHkxLFxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxuICAgICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgICBsMDFfMiA9IHgwMSAqIHgwMSArIHkwMSAqIHkwMTtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiICsgcik7IH1cblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDEseTEpLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3IsIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4MCx5MCk/IERvIG5vdGhpbmcuXG4gICAgZWxzZSBpZiAoIShsMDFfMiA+IGVwc2lsb24pKSB7fVxuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAoeDEgKyB0MDEgKiB4MDEpICsgXCIsXCIgKyAoeTEgKyB0MDEgKiB5MDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwwLFwiICsgKCsoeTAxICogeDIwID4geDAxICogeTIwKSkgKyBcIixcIiArICh0aGlzLl94MSA9IHgxICsgdDIxICogeDIxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEgKyB0MjEgKiB5MjEpO1xuICAgIH1cbiAgfSxcbiAgYXJjOiBmdW5jdGlvbih4LCB5LCByLCBhMCwgYTEsIGNjdykge1xuICAgIHggPSAreCwgeSA9ICt5LCByID0gK3I7XG4gICAgdmFyIGR4ID0gciAqIE1hdGguY29zKGEwKSxcbiAgICAgICAgZHkgPSByICogTWF0aC5zaW4oYTApLFxuICAgICAgICB4MCA9IHggKyBkeCxcbiAgICAgICAgeTAgPSB5ICsgZHksXG4gICAgICAgIGN3ID0gMSBeIGNjdyxcbiAgICAgICAgZGEgPSBjY3cgPyBhMCAtIGExIDogYTEgLSBhMDtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiICsgcik7IH1cblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSB7IHJldHVybjsgfVxuXG4gICAgLy8gRG9lcyB0aGUgYW5nbGUgZ28gdGhlIHdyb25nIHdheT8gRmxpcCB0aGUgZGlyZWN0aW9uLlxuICAgIGlmIChkYSA8IDApIHsgZGEgPSBkYSAlIHRhdSArIHRhdTsgfVxuXG4gICAgLy8gSXMgdGhpcyBhIGNvbXBsZXRlIGNpcmNsZT8gRHJhdyB0d28gYXJjcyB0byBjb21wbGV0ZSB0aGUgY2lyY2xlLlxuICAgIGlmIChkYSA+IHRhdUVwc2lsb24pIHtcbiAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDEsXCIgKyBjdyArIFwiLFwiICsgKHggLSBkeCkgKyBcIixcIiArICh5IC0gZHkpICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh0aGlzLl94MSA9IHgwKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTApO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIG5vbi1lbXB0eT8gRHJhdyBhbiBhcmMhXG4gICAgZWxzZSBpZiAoZGEgPiBlcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCxcIiArICgrKGRhID49IHBpKSkgKyBcIixcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4ICsgciAqIE1hdGguY29zKGExKSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkgKyByICogTWF0aC5zaW4oYTEpKTtcbiAgICB9XG4gIH0sXG4gIHJlY3Q6IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSkgKyBcImhcIiArICgrdykgKyBcInZcIiArICgraCkgKyBcImhcIiArICgtdykgKyBcIlpcIjtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG5cbmZ1bmN0aW9uIExpbmVhcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXIucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB7IHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7IH1cbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjdXJ2ZUxpbmVhcihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiB4KHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmZ1bmN0aW9uIHkocCkge1xuICByZXR1cm4gcFsxXTtcbn1cblxuZnVuY3Rpb24gbGluZSgpIHtcbiAgdmFyIHgkJDEgPSB4LFxuICAgICAgeSQkMSA9IHksXG4gICAgICBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGxpbmUoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIHsgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTsgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSB7IG91dHB1dC5saW5lU3RhcnQoKTsgfVxuICAgICAgICBlbHNlIHsgb3V0cHV0LmxpbmVFbmQoKTsgfVxuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSB7IG91dHB1dC5wb2ludCgreCQkMShkLCBpLCBkYXRhKSwgK3kkJDEoZCwgaSwgZGF0YSkpOyB9XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsOyB9XG4gIH1cblxuICBsaW5lLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCQkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHgkJDE7XG4gIH07XG5cbiAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB5JCQxO1xuICB9O1xuXG4gIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBsaW5lKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgbGluZS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBsaW5lKSA6IGN1cnZlO1xuICB9O1xuXG4gIGxpbmUuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgbGluZSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5lO1xufVxuXG5mdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICB0aGF0Ll94MSArIHRoYXQuX2sgKiAodGhhdC5feDIgLSB0aGF0Ll94MCksXG4gICAgdGhhdC5feTEgKyB0aGF0Ll9rICogKHRoYXQuX3kyIC0gdGhhdC5feTApLFxuICAgIHRoYXQuX3gyICsgdGhhdC5fayAqICh0aGF0Ll94MSAtIHgpLFxuICAgIHRoYXQuX3kyICsgdGhhdC5fayAqICh0aGF0Ll95MSAtIHkpLFxuICAgIHRoYXQuX3gyLFxuICAgIHRoYXQuX3kyXG4gICk7XG59XG5cbmZ1bmN0aW9uIENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgeyB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpOyB9XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDEgPSB4LCB0aGlzLl95MSA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhcmRpbmFsID0gKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuXG52YXIgVHJhbnMgPSB7XG4gIG5hbWU6ICdFbFRyYW5zJyxcblxuICBmdW5jdGlvbmFsOiB0cnVlLFxuXG4gIHByb3BzOiBbJ2Zyb20nLCAndHJhbnMnXSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCByZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuXG4gICAgcmV0dXJuIGgoXG4gICAgICAndHJhbnNpdGlvbicsXG4gICAgICB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgYXBwZWFyOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgYmVmb3JlQXBwZWFyOiBmdW5jdGlvbiBiZWZvcmVBcHBlYXIoZWwpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzLmZyb20pIHtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHByb3BzLmZyb21ba2V5XTtcbiAgICAgICAgICAgICAgdmFyIHRvID0gZWwuZ2V0QXR0cmlidXRlKGtleSk7XG5cbiAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKChcImRhdGEtXCIgKyBrZXkpLCB0byk7XG4gICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFwcGVhcjogZnVuY3Rpb24gYXBwZWFyKGVsKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHByb3BzLnRyYW5zO1xuICAgICAgICAgICAgICBlbC5zdHlsZS5XZWJraXRUcmFuc2l0aW9uID0gcHJvcHMudHJhbnM7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLm1zVHJhbnNpdGlvbiA9IHByb3BzLnRyYW5zO1xuICAgICAgICAgICAgICBlbC5zdHlsZS5Nb3pUcmFuc2l0aW9uID0gcHJvcHMudHJhbnM7XG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvID0gZWwuZ2V0QXR0cmlidXRlKChcImRhdGEtXCIgKyBrZXkpKTtcblxuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHRvKTtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoKFwiZGF0YS1cIiArIGtleSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjaGlsZHJlblxuICAgIClcbiAgfVxufVxuXG52YXIgU3ByZWFkID0ge1xuICBuYW1lOiAnTGFNb3Rpb25TcHJlYWQnLFxuXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG5cbiAgcHJvcHM6IFsnYXhpcycsICd0cmFuc2l0aW9uJ10sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgcmVmKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwcm9wcyA9IHJlZi5wcm9wcztcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcblxuICAgIHZhciBpZCA9IFwibGEtc3ByZWFkLVwiICsgKHBhcmVudC5fdWlkKTtcbiAgICB2YXIgYXhpcyA9IHByb3BzLmF4aXM7XG4gICAgdmFyIHRyYW5zaXRpb24gPSBwcm9wcy50cmFuc2l0aW9uO1xuXG4gICAgcmV0dXJuIGgoJ2cnLCBbXG4gICAgICBoKCdkZWZzJywgW1xuICAgICAgICBoKFxuICAgICAgICAgICdjbGlwUGF0aCcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBoKFxuICAgICAgICAgICAgICBUcmFucyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBheGlzID09PSAneCcgPyAwIDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGF4aXMgPT09ICd5JyA/IDAgOiAnMTAwJSdcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGgoJ3JlY3QnLCB7XG4gICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIClcbiAgICAgICAgICBdXG4gICAgICAgIClcbiAgICAgIF0pLFxuICAgICAgaChcbiAgICAgICAgJ2cnLFxuICAgICAgICB7XG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICdjbGlwLXBhdGgnOiAoXCJ1cmwoI1wiICsgaWQgKyBcIilcIilcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApXG4gICAgXSlcbiAgfVxufVxuXG52YXIgZGFzaGVkID0ge1xuICBwcm9wczoge1xuICAgIGRhc2hlZDogW0Jvb2xlYW4sIFN0cmluZ11cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIGN1ckRhc2hlZDogZnVuY3Rpb24gY3VyRGFzaGVkKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgZGFzaGVkID0gcmVmLmRhc2hlZDtcblxuICAgICAgcmV0dXJuIGRhc2hlZCA9PT0gdHJ1ZSB8fCBkYXNoZWQgPT09ICcnID9cbiAgICAgICAgMyA6XG4gICAgICAgIGRhc2hlZCA9PT0gZmFsc2UgPyAnbm9uZScgOiBkYXNoZWRcbiAgICB9XG4gIH1cbn1cblxudmFyIExpbmUgPSB7XG4gIG5hbWU6ICdMYUxpbmUnLFxuXG4gIG1peGluczogW2NhcnRlc2lhbiwgZGFzaGVkXSxcblxuICBwcm9wczoge1xuICAgIGN1cnZlOiBbQm9vbGVhbiwgRnVuY3Rpb25dLFxuXG4gICAgZG90OiBCb29sZWFuLFxuXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDFcbiAgICB9LFxuXG4gICAgaGlkZUxpbmU6IEJvb2xlYW4sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBMaWtlIGNvbm5lY3ROdWxsc1xuICAgICAqL1xuICAgIGNvbnRpbnVlZDogQm9vbGVhblxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnZlID0gcmVmLmN1cnZlO1xuICAgICAgdmFyIGNvbnRpbnVlZCA9IHJlZi5jb250aW51ZWQ7XG4gICAgICB2YXIgZHJhdyA9IGxpbmUoKS5kZWZpbmVkKG5vTmlsSW5BcnJheSk7XG5cbiAgICAgIGlmIChjdXJ2ZSkge1xuICAgICAgICBkcmF3LmN1cnZlKGlzRm4oY3VydmUpID8gY3VydmUgOiBjYXJkaW5hbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwID0gY29udGludWVkID8gcC5maWx0ZXIobm9OaWxJbkFycmF5KSA6IHA7XG4gICAgICAgIHJldHVybiBkcmF3KHApXG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbHVlU2xvdDogZnVuY3Rpb24gdmFsdWVTbG90KCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBoID0gdGhpcy4kY3JlYXRlRWxlbWVudDtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5zaG93VmFsdWUgJiZcbiAgICAgICAgaChcbiAgICAgICAgICAnZycsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgZmlsbDogdGhpcy5jdXJDb2xvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhpcy5jdXJQb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCQkMSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGgoXG4gICAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICB4OiBwb2ludCQkMVswXSxcbiAgICAgICAgICAgICAgICAgIHk6IHBvaW50JCQxWzFdLFxuICAgICAgICAgICAgICAgICAgZHk6ICctMC4zMWVtJyxcbiAgICAgICAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0aGlzJDEucmF3c1tpXVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBhbmltYXRlZCA9IHJlZi5hbmltYXRlZDtcbiAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XG4gICAgdmFyIGN1clBvaW50cyA9IHJlZi5jdXJQb2ludHM7XG4gICAgdmFyIGN1ckNvbG9yID0gcmVmLmN1ckNvbG9yO1xuICAgIHZhciBoaWRlTGluZSA9IHJlZi5oaWRlTGluZTtcbiAgICB2YXIgdHJhbnMgPSByZWYudHJhbnM7XG4gICAgdmFyIHZhbHVlU2xvdCA9IHJlZi52YWx1ZVNsb3Q7XG4gICAgdmFyIHBvaW50U2xvdCA9IHJlZi5wb2ludFNsb3Q7XG4gICAgdmFyIHN0b3JlID0gcmVmLnN0b3JlO1xuICAgIHZhciBhY3RpdmVkID0gcmVmLmFjdGl2ZWQ7XG5cbiAgICBpZiAoIWFjdGl2ZWQpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdmFyIGdyYXBocyA9IFtcbiAgICAgICFoaWRlTGluZSAmJlxuICAgICAgICBoKCdwYXRoJywge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzdHJva2U6IGN1ckNvbG9yLFxuICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHdpZHRoLFxuICAgICAgICAgICAgZDogdGhpcy5kcmF3KGN1clBvaW50cylcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IHRoaXMuY3VyRGFzaGVkLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdCxcbiAgICAgIHRoaXMuZG90ICYmXG4gICAgICAgIGgoXG4gICAgICAgICAgJ2cnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHN0cm9rZTogJyNmZmYnLFxuICAgICAgICAgICAgICBmaWxsOiBjdXJDb2xvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VyUG9pbnRzLm1hcChcbiAgICAgICAgICAgIGZ1bmN0aW9uIChwLCBpbmRleCkgeyByZXR1cm4gcFsxXSAmJlxuICAgICAgICAgICAgICBoKCdjaXJjbGUnLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgIGN4OiBwWzBdLFxuICAgICAgICAgICAgICAgICAgY3k6IHBbMV0sXG4gICAgICAgICAgICAgICAgICByOiAoaW5kZXggPT09IHN0b3JlLmFjdGl2ZWRJbmRleCA/IDIgOiAwKSArIGludCh3aWR0aCkgKyAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pOyB9XG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgdmFsdWVTbG90LFxuICAgICAgcG9pbnRTbG90XG4gICAgXTtcblxuICAgIGlmIChhbmltYXRlZCkge1xuICAgICAgcmV0dXJuIGgoXG4gICAgICAgIFNwcmVhZCxcbiAgICAgICAge1xuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBheGlzOiAneCcsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ3JhcGhzXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIGgoJ2cnLCBncmFwaHMpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXJlYSgpIHtcbiAgdmFyIHgwID0geCxcbiAgICAgIHgxID0gbnVsbCxcbiAgICAgIHkwID0gY29uc3RhbnQoMCksXG4gICAgICB5MSA9IHksXG4gICAgICBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgeDB6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICB5MHogPSBuZXcgQXJyYXkobik7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7IG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7IH1cblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkge1xuICAgICAgICAgIGogPSBpO1xuICAgICAgICAgIG91dHB1dC5hcmVhU3RhcnQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChrID0gaSAtIDE7IGsgPj0gajsgLS1rKSB7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnQoeDB6W2tdLCB5MHpba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5hcmVhRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkge1xuICAgICAgICB4MHpbaV0gPSAreDAoZCwgaSwgZGF0YSksIHkweltpXSA9ICt5MChkLCBpLCBkYXRhKTtcbiAgICAgICAgb3V0cHV0LnBvaW50KHgxID8gK3gxKGQsIGksIGRhdGEpIDogeDB6W2ldLCB5MSA/ICt5MShkLCBpLCBkYXRhKSA6IHkweltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsOyB9XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhbGluZSgpIHtcbiAgICByZXR1cm4gbGluZSgpLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpLmNvbnRleHQoY29udGV4dCk7XG4gIH1cblxuICBhcmVhLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeDEgPSBudWxsLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgxO1xuICB9O1xuXG4gIGFyZWEueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB5MSA9IG51bGwsIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTE7XG4gIH07XG5cbiAgYXJlYS5saW5lWDAgPVxuICBhcmVhLmxpbmVZMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTApO1xuICB9O1xuXG4gIGFyZWEubGluZVkxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MSk7XG4gIH07XG5cbiAgYXJlYS5saW5lWDEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgxKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYXJlYSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGFyZWEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgYXJlYSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBhcmVhLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGFyZWEpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJlYTtcbn1cblxudmFyIEFyZWEgPSB7XG4gIG5hbWU6ICdMYUFyZWEnLFxuXG4gIG1peGluczogW0xpbmVdLFxuXG4gIHByb3BzOiB7XG4gICAgZmlsbENvbG9yOiBTdHJpbmdcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBjdXJ2ZSA9IHJlZi5jdXJ2ZTtcbiAgICAgIHZhciBjb250aW51ZWQgPSByZWYuY29udGludWVkO1xuICAgICAgdmFyIGRyYXcgPSBhcmVhKClcbiAgICAgICAgLnkwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkWzJdOyB9KVxuICAgICAgICAuZGVmaW5lZChub05pbEluQXJyYXkpO1xuXG4gICAgICBpZiAoY3VydmUpIHtcbiAgICAgICAgZHJhdy5jdXJ2ZShpc0ZuKGN1cnZlKSA/IGN1cnZlIDogY2FyZGluYWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcCA9IGNvbnRpbnVlZCA/IHAuZmlsdGVyKG5vTmlsSW5BcnJheSkgOiBwO1xuICAgICAgICByZXR1cm4gZHJhdyhwKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhcmVhSWQ6IGZ1bmN0aW9uIGFyZWFJZCgpIHtcbiAgICAgIHJldHVybiAoXCJsYS1hcmVhLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIiArICh0aGlzLmlkKSlcbiAgICB9LFxuXG4gICAgY3VyRmlsbENvbG9yOiBmdW5jdGlvbiBjdXJGaWxsQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxsQ29sb3IgfHwgKFwidXJsKCNcIiArICh0aGlzLmFyZWFJZCkgKyBcIilcIilcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciB0cmFucyA9IHJlZi50cmFucztcbiAgICB2YXIgY3VyUG9pbnRzID0gcmVmLmN1clBvaW50cztcbiAgICB2YXIgY3VyQ29sb3IgPSByZWYuY3VyQ29sb3I7XG4gICAgdmFyIGN1ckZpbGxDb2xvciA9IHJlZi5jdXJGaWxsQ29sb3I7XG4gICAgdmFyIGFjdGl2ZWQgPSByZWYuYWN0aXZlZDtcblxuICAgIGlmICghYWN0aXZlZCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gaCgnZycsIFtcbiAgICAgICF0aGlzLmZpbGxDb2xvciAmJlxuICAgICAgICBoKCdkZWZzJywgW1xuICAgICAgICAgIGgoXG4gICAgICAgICAgICAnbGluZWFyR3JhZGllbnQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBJIGRvbid0IGtvd24gd2h5IHVzaW5nIGBhdHRyc2AgY2F1c2VzIHRoZSBjbGllbnQgbm90IHRvIHJlcmVuZGVyIGlmIHRoZSBzZXJ2ZXIgaGFzIGFscmVhZHkgcmVuZGVyZWQuXG4gICAgICAgICAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuYXJlYUlkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIGgoJ3N0b3AnLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICdzdG9wLWNvbG9yJzogY3VyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAnc3RvcC1vcGFjaXR5JzogMC41XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgXSksXG4gICAgICBoKFxuICAgICAgICBMaW5lLFxuICAgICAgICB7XG4gICAgICAgICAgcHJvcHM6IGV4dGVuZChleHRlbmQoe30sIHRoaXMuJHByb3BzKSwge1xuICAgICAgICAgICAgY29sb3I6IGN1ckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRzOiBjdXJQb2ludHMsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHNjb3BlZFNsb3RzOiB0aGlzLiRzY29wZWRTbG90c1xuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgaCgncGF0aCcsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGQ6IHRoaXMuZHJhdyhjdXJQb2ludHMpLFxuICAgICAgICAgICAgICBmaWxsOiBjdXJGaWxsQ29sb3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRoaXMuJHNsb3RzLmRlZmF1bHRcbiAgICAgICAgXVxuICAgICAgKVxuICAgIF0pXG4gIH1cbn1cblxudmFyIERFRkFVTFRfV0lEVEggPSAyMDtcblxudmFyIEJhciA9IHtcbiAgbmFtZTogJ0xhQmFyJyxcblxuICBtaXhpbnM6IFtjYXJ0ZXNpYW5dLFxuXG4gIHByb3BzOiB7XG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IERFRkFVTFRfV0lEVEhcbiAgICB9XG4gIH0sXG5cbiAgcHJlbG9hZDogZnVuY3Rpb24gcHJlbG9hZChyZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHZhciBpbmRleCA9IHJlZi5pbmRleDtcblxuICAgIHZhciBzbmFwID0gcGFyZW50LnNuYXA7XG4gICAgdmFyIGRpc3RhbmNlID0gcGFyZW50LmRpc3RhbmNlO1xuICAgIHZhciB3aWR0aCA9IGRhdGEud2lkdGggfHwgREVGQVVMVF9XSURUSDtcblxuICAgIHNuYXAuYmFyTWFwID0gW10uY29uY2F0KHNuYXAuYmFyTWFwLCBpbmRleCk7XG4gICAgc25hcC5iYXJBbGxXaWR0aCA9IHNuYXAuYmFyQWxsV2lkdGggfHwgMDtcbiAgICBzbmFwLmJhck9mZnNldCA9IFtdLmNvbmNhdChzbmFwLmJhck9mZnNldCwgc25hcC5iYXJBbGxXaWR0aCk7XG4gICAgc25hcC5iYXJBbGxXaWR0aCArPSB3aWR0aCArIGRpc3RhbmNlO1xuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgbWFyZ2luOiBmdW5jdGlvbiBtYXJnaW4oKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBpZCA9IHJlZi5pZDtcbiAgICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICAgIHZhciByZWYkMSA9IHRoaXMuUGxhbmU7XG4gICAgICB2YXIgc25hcCA9IHJlZiQxLnNuYXA7XG4gICAgICB2YXIgZGlzdGFuY2UgPSByZWYkMS5kaXN0YW5jZTtcbiAgICAgIHZhciBzdGFja2VkID0gcmVmJDEuc3RhY2tlZDtcbiAgICAgIHZhciBpbmRleCA9IHNuYXAuYmFyTWFwLmluZGV4T2YoaWQpO1xuXG4gICAgICByZXR1cm4gc3RhY2tlZCA/XG4gICAgICAgIC13aWR0aCAvIDIgOlxuICAgICAgICBzbmFwLmJhck9mZnNldFtpbmRleF0gLSAoc25hcC5iYXJBbGxXaWR0aCAtIGRpc3RhbmNlKSAvIDJcbiAgICB9LFxuXG4gICAgdmFsdWVTbG90OiBmdW5jdGlvbiB2YWx1ZVNsb3QoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGggPSB0aGlzLiRjcmVhdGVFbGVtZW50O1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnNob3dWYWx1ZSAmJlxuICAgICAgICBoKFxuICAgICAgICAgICdnJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICBmaWxsOiAnI2ZmZidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoaXMuY3VyUG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBoKFxuICAgICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgeDogcG9pbnRbMF0gKyB0aGlzJDEubWFyZ2luICsgdGhpcyQxLndpZHRoIC8gMixcbiAgICAgICAgICAgICAgICAgIHk6IHBvaW50WzJdICsgKHBvaW50WzFdIC0gcG9pbnRbMl0pIC8gMixcbiAgICAgICAgICAgICAgICAgIGR5OiAnMC4zMWVtJyxcbiAgICAgICAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0aGlzJDEucmF3c1tpXVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGdldFJlY3Q6IGZ1bmN0aW9uIGdldFJlY3QocG9pbnQpIHtcbiAgICAgIHZhciBoZWlnaHQgPSBwb2ludFsyXSAtIHBvaW50WzFdO1xuXG4gICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgncmVjdCcsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB4OiBwb2ludFswXSArIHRoaXMubWFyZ2luLFxuICAgICAgICAgIHk6IGhlaWdodCA8IDAgPyBwb2ludFsyXSA6IHBvaW50WzFdLFxuICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5hYnMoaGVpZ2h0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgY3VyUG9pbnRzID0gcmVmLmN1clBvaW50cztcbiAgICB2YXIgY3VyQ29sb3IgPSByZWYuY3VyQ29sb3I7XG4gICAgdmFyIGFuaW1hdGVkID0gcmVmLmFuaW1hdGVkO1xuICAgIHZhciB0cmFucyA9IHJlZi50cmFucztcbiAgICB2YXIgcG9pbnRTbG90ID0gcmVmLnBvaW50U2xvdDtcbiAgICB2YXIgdmFsdWVTbG90ID0gcmVmLnZhbHVlU2xvdDtcbiAgICB2YXIgYWN0aXZlZCA9IHJlZi5hY3RpdmVkO1xuXG4gICAgaWYgKCFhY3RpdmVkKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciByZWN0cyA9IFtdO1xuXG4gICAgaWYgKGFuaW1hdGVkKSB7XG4gICAgICByZWN0cyA9IGN1clBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBoKFxuICAgICAgICAgIFRyYW5zLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgeTogdGhpcyQxLlBsYW5lLmNhbnZhcy55MVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0cmFuczogdHJhbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFt0aGlzJDEuZ2V0UmVjdChwb2ludCldXG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0cyA9IGN1clBvaW50cy5tYXAodGhpcy5nZXRSZWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaChcbiAgICAgICdnJyxcbiAgICAgIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBmaWxsOiBjdXJDb2xvclxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW10uY29uY2F0KHJlY3RzLCB2YWx1ZVNsb3QsIHBvaW50U2xvdClcbiAgICApXG4gIH1cbn1cblxudmFyIHBvbGFyID0ge1xuICB0eXBlOiAncG9sYXInLFxuXG4gIG1peGluczogW2NoYXJ0XVxufVxuXG5mdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eShkKSB7XG4gIHJldHVybiBkO1xufVxuXG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbnZhciBlcHNpbG9uJDEgPSAxZS0xMjtcbnZhciBwaSQxID0gTWF0aC5QSTtcbnZhciBoYWxmUGkgPSBwaSQxIC8gMjtcbnZhciB0YXUkMSA9IDIgKiBwaSQxO1xuXG5mdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpJDEgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+PSAxID8gaGFsZlBpIDogeCA8PSAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmZ1bmN0aW9uIHBpZSgpIHtcbiAgdmFyIHZhbHVlID0gaWRlbnRpdHksXG4gICAgICBzb3J0VmFsdWVzID0gZGVzY2VuZGluZyxcbiAgICAgIHNvcnQgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGNvbnN0YW50KDApLFxuICAgICAgZW5kQW5nbGUgPSBjb25zdGFudCh0YXUkMSksXG4gICAgICBwYWRBbmdsZSA9IGNvbnN0YW50KDApO1xuXG4gIGZ1bmN0aW9uIHBpZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgaW5kZXggPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGFyY3MgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGEwID0gK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgZGEgPSBNYXRoLm1pbih0YXUkMSwgTWF0aC5tYXgoLXRhdSQxLCBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gYTApKSxcbiAgICAgICAgYTEsXG4gICAgICAgIHAgPSBNYXRoLm1pbihNYXRoLmFicyhkYSkgLyBuLCBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSxcbiAgICAgICAgcGEgPSBwICogKGRhIDwgMCA/IC0xIDogMSksXG4gICAgICAgIHY7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHYgPSBhcmNzW2luZGV4W2ldID0gaV0gPSArdmFsdWUoZGF0YVtpXSwgaSwgZGF0YSkpID4gMCkge1xuICAgICAgICBzdW0gKz0gdjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcHRpb25hbGx5IHNvcnQgdGhlIGFyY3MgYnkgcHJldmlvdXNseS1jb21wdXRlZCB2YWx1ZXMgb3IgYnkgZGF0YS5cbiAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKSB7IGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydFZhbHVlcyhhcmNzW2ldLCBhcmNzW2pdKTsgfSk7IH1cbiAgICBlbHNlIGlmIChzb3J0ICE9IG51bGwpIHsgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0KGRhdGFbaV0sIGRhdGFbal0pOyB9KTsgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYXJjcyEgVGhleSBhcmUgc3RvcmVkIGluIHRoZSBvcmlnaW5hbCBkYXRhJ3Mgb3JkZXIuXG4gICAgZm9yIChpID0gMCwgayA9IHN1bSA/IChkYSAtIG4gKiBwYSkgLyBzdW0gOiAwOyBpIDwgbjsgKytpLCBhMCA9IGExKSB7XG4gICAgICBqID0gaW5kZXhbaV0sIHYgPSBhcmNzW2pdLCBhMSA9IGEwICsgKHYgPiAwID8gdiAqIGsgOiAwKSArIHBhLCBhcmNzW2pdID0ge1xuICAgICAgICBkYXRhOiBkYXRhW2pdLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxuICAgICAgICBlbmRBbmdsZTogYTEsXG4gICAgICAgIHBhZEFuZ2xlOiBwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBhcmNzO1xuICB9XG5cbiAgcGllLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiB2YWx1ZTtcbiAgfTtcblxuICBwaWUuc29ydFZhbHVlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0VmFsdWVzID0gXywgc29ydCA9IG51bGwsIHBpZSkgOiBzb3J0VmFsdWVzO1xuICB9O1xuXG4gIHBpZS5zb3J0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnQgPSBfLCBzb3J0VmFsdWVzID0gbnVsbCwgcGllKSA6IHNvcnQ7XG4gIH07XG5cbiAgcGllLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBwaWUuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgcmV0dXJuIHBpZTtcbn1cblxuZnVuY3Rpb24gYXJjSW5uZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5pbm5lclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjT3V0ZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5vdXRlclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjU3RhcnRBbmdsZShkKSB7XG4gIHJldHVybiBkLnN0YXJ0QW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY0VuZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY1BhZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTsgLy8gTm90ZTogb3B0aW9uYWwhXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIHgxMCA9IHgxIC0geDAsIHkxMCA9IHkxIC0geTAsXG4gICAgICB4MzIgPSB4MyAtIHgyLCB5MzIgPSB5MyAtIHkyLFxuICAgICAgdCA9ICh4MzIgKiAoeTAgLSB5MikgLSB5MzIgKiAoeDAgLSB4MikpIC8gKHkzMiAqIHgxMCAtIHgzMiAqIHkxMCk7XG4gIHJldHVybiBbeDAgKyB0ICogeDEwLCB5MCArIHQgKiB5MTBdO1xufVxuXG4vLyBDb21wdXRlIHBlcnBlbmRpY3VsYXIgb2Zmc2V0IGxpbmUgb2YgbGVuZ3RoIHJjLlxuLy8gaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9DaXJjbGUtTGluZUludGVyc2VjdGlvbi5odG1sXG5mdW5jdGlvbiBjb3JuZXJUYW5nZW50cyh4MCwgeTAsIHgxLCB5MSwgcjEsIHJjLCBjdykge1xuICB2YXIgeDAxID0geDAgLSB4MSxcbiAgICAgIHkwMSA9IHkwIC0geTEsXG4gICAgICBsbyA9IChjdyA/IHJjIDogLXJjKSAvIHNxcnQoeDAxICogeDAxICsgeTAxICogeTAxKSxcbiAgICAgIG94ID0gbG8gKiB5MDEsXG4gICAgICBveSA9IC1sbyAqIHgwMSxcbiAgICAgIHgxMSA9IHgwICsgb3gsXG4gICAgICB5MTEgPSB5MCArIG95LFxuICAgICAgeDEwID0geDEgKyBveCxcbiAgICAgIHkxMCA9IHkxICsgb3ksXG4gICAgICB4MDAgPSAoeDExICsgeDEwKSAvIDIsXG4gICAgICB5MDAgPSAoeTExICsgeTEwKSAvIDIsXG4gICAgICBkeCA9IHgxMCAtIHgxMSxcbiAgICAgIGR5ID0geTEwIC0geTExLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgIHIgPSByMSAtIHJjLFxuICAgICAgRCA9IHgxMSAqIHkxMCAtIHgxMCAqIHkxMSxcbiAgICAgIGQgPSAoZHkgPCAwID8gLTEgOiAxKSAqIHNxcnQobWF4KDAsIHIgKiByICogZDIgLSBEICogRCkpLFxuICAgICAgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MCA9ICgtRCAqIGR4IC0gZHkgKiBkKSAvIGQyLFxuICAgICAgY3gxID0gKEQgKiBkeSArIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLFxuICAgICAgZHgwID0gY3gwIC0geDAwLFxuICAgICAgZHkwID0gY3kwIC0geTAwLFxuICAgICAgZHgxID0gY3gxIC0geDAwLFxuICAgICAgZHkxID0gY3kxIC0geTAwO1xuXG4gIC8vIFBpY2sgdGhlIGNsb3NlciBvZiB0aGUgdHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gIC8vIFRPRE8gSXMgdGhlcmUgYSBmYXN0ZXIgd2F5IHRvIGRldGVybWluZSB3aGljaCBpbnRlcnNlY3Rpb24gdG8gdXNlP1xuICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSB7IGN4MCA9IGN4MSwgY3kwID0gY3kxOyB9XG5cbiAgcmV0dXJuIHtcbiAgICBjeDogY3gwLFxuICAgIGN5OiBjeTAsXG4gICAgeDAxOiAtb3gsXG4gICAgeTAxOiAtb3ksXG4gICAgeDExOiBjeDAgKiAocjEgLyByIC0gMSksXG4gICAgeTExOiBjeTAgKiAocjEgLyByIC0gMSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXJjKCkge1xuICB2YXIgaW5uZXJSYWRpdXMgPSBhcmNJbm5lclJhZGl1cyxcbiAgICAgIG91dGVyUmFkaXVzID0gYXJjT3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb25zdGFudCgwKSxcbiAgICAgIHBhZFJhZGl1cyA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gYXJjU3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gYXJjRW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IGFyY1BhZEFuZ2xlLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJjKCkge1xuICAgIHZhciBidWZmZXIsXG4gICAgICAgIHIsXG4gICAgICAgIHIwID0gK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHIxID0gK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGRhID0gYWJzKGExIC0gYTApLFxuICAgICAgICBjdyA9IGExID4gYTA7XG5cbiAgICBpZiAoIWNvbnRleHQpIHsgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTsgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIG91dGVyIHJhZGl1cyBpcyBhbHdheXMgbGFyZ2VyIHRoYW4gdGhlIGlubmVyIHJhZGl1cy5cbiAgICBpZiAocjEgPCByMCkgeyByID0gcjEsIHIxID0gcjAsIHIwID0gcjsgfVxuXG4gICAgLy8gSXMgaXQgYSBwb2ludD9cbiAgICBpZiAoIShyMSA+IGVwc2lsb24kMSkpIHsgY29udGV4dC5tb3ZlVG8oMCwgMCk7IH1cblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY2xlIG9yIGFubnVsdXM/XG4gICAgZWxzZSBpZiAoZGEgPiB0YXUkMSAtIGVwc2lsb24kMSkge1xuICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBjb3MoYTApLCByMSAqIHNpbihhMCkpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwLCBhMSwgIWN3KTtcbiAgICAgIGlmIChyMCA+IGVwc2lsb24kMSkge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhyMCAqIGNvcyhhMSksIHIwICogc2luKGExKSk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGEwMSA9IGEwLFxuICAgICAgICAgIGExMSA9IGExLFxuICAgICAgICAgIGEwMCA9IGEwLFxuICAgICAgICAgIGExMCA9IGExLFxuICAgICAgICAgIGRhMCA9IGRhLFxuICAgICAgICAgIGRhMSA9IGRhLFxuICAgICAgICAgIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uJDEpICYmIChwYWRSYWRpdXMgPyArcGFkUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBzcXJ0KHIwICogcjAgKyByMSAqIHIxKSksXG4gICAgICAgICAgcmMgPSBtaW4oYWJzKHIxIC0gcjApIC8gMiwgK2Nvcm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSxcbiAgICAgICAgICByYzAgPSByYyxcbiAgICAgICAgICByYzEgPSByYyxcbiAgICAgICAgICB0MCxcbiAgICAgICAgICB0MTtcblxuICAgICAgLy8gQXBwbHkgcGFkZGluZz8gTm90ZSB0aGF0IHNpbmNlIHIxIOKJpSByMCwgZGExIOKJpSBkYTAuXG4gICAgICBpZiAocnAgPiBlcHNpbG9uJDEpIHtcbiAgICAgICAgdmFyIHAwID0gYXNpbihycCAvIHIwICogc2luKGFwKSksXG4gICAgICAgICAgICBwMSA9IGFzaW4ocnAgLyByMSAqIHNpbihhcCkpO1xuICAgICAgICBpZiAoKGRhMCAtPSBwMCAqIDIpID4gZXBzaWxvbiQxKSB7IHAwICo9IChjdyA/IDEgOiAtMSksIGEwMCArPSBwMCwgYTEwIC09IHAwOyB9XG4gICAgICAgIGVsc2UgeyBkYTAgPSAwLCBhMDAgPSBhMTAgPSAoYTAgKyBhMSkgLyAyOyB9XG4gICAgICAgIGlmICgoZGExIC09IHAxICogMikgPiBlcHNpbG9uJDEpIHsgcDEgKj0gKGN3ID8gMSA6IC0xKSwgYTAxICs9IHAxLCBhMTEgLT0gcDE7IH1cbiAgICAgICAgZWxzZSB7IGRhMSA9IDAsIGEwMSA9IGExMSA9IChhMCArIGExKSAvIDI7IH1cbiAgICAgIH1cblxuICAgICAgdmFyIHgwMSA9IHIxICogY29zKGEwMSksXG4gICAgICAgICAgeTAxID0gcjEgKiBzaW4oYTAxKSxcbiAgICAgICAgICB4MTAgPSByMCAqIGNvcyhhMTApLFxuICAgICAgICAgIHkxMCA9IHIwICogc2luKGExMCk7XG5cbiAgICAgIC8vIEFwcGx5IHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGlmIChyYyA+IGVwc2lsb24kMSkge1xuICAgICAgICB2YXIgeDExID0gcjEgKiBjb3MoYTExKSxcbiAgICAgICAgICAgIHkxMSA9IHIxICogc2luKGExMSksXG4gICAgICAgICAgICB4MDAgPSByMCAqIGNvcyhhMDApLFxuICAgICAgICAgICAgeTAwID0gcjAgKiBzaW4oYTAwKTtcblxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS5cbiAgICAgICAgaWYgKGRhIDwgcGkkMSkge1xuICAgICAgICAgIHZhciBvYyA9IGRhMCA+IGVwc2lsb24kMSA/IGludGVyc2VjdCh4MDEsIHkwMSwgeDAwLCB5MDAsIHgxMSwgeTExLCB4MTAsIHkxMCkgOiBbeDEwLCB5MTBdLFxuICAgICAgICAgICAgICBheCA9IHgwMSAtIG9jWzBdLFxuICAgICAgICAgICAgICBheSA9IHkwMSAtIG9jWzFdLFxuICAgICAgICAgICAgICBieCA9IHgxMSAtIG9jWzBdLFxuICAgICAgICAgICAgICBieSA9IHkxMSAtIG9jWzFdLFxuICAgICAgICAgICAgICBrYyA9IDEgLyBzaW4oYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKHNxcnQoYXggKiBheCArIGF5ICogYXkpICogc3FydChieCAqIGJ4ICsgYnkgKiBieSkpKSAvIDIpLFxuICAgICAgICAgICAgICBsYyA9IHNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgIHJjMCA9IG1pbihyYywgKHIwIC0gbGMpIC8gKGtjIC0gMSkpO1xuICAgICAgICAgIHJjMSA9IG1pbihyYywgKHIxIC0gbGMpIC8gKGtjICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElzIHRoZSBzZWN0b3IgY29sbGFwc2VkIHRvIGEgbGluZT9cbiAgICAgIGlmICghKGRhMSA+IGVwc2lsb24kMSkpIHsgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpOyB9XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgb3V0ZXIgcmluZyBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMSA+IGVwc2lsb24kMSkge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgwMCwgeTAwLCB4MDEsIHkwMSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgxMSwgeTExLCB4MTAsIHkxMCwgcjEsIHJjMSwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzEgPCByYykgeyBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7IH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMxLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgb3V0ZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSB7IGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKSwgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwMSwgYTExLCAhY3cpOyB9XG5cbiAgICAgIC8vIElzIHRoZXJlIG5vIGlubmVyIHJpbmcsIGFuZCBpdOKAmXMgYSBjaXJjdWxhciBzZWN0b3I/XG4gICAgICAvLyBPciBwZXJoYXBzIGl04oCZcyBhbiBhbm51bGFyIHNlY3RvciBjb2xsYXBzZWQgZHVlIHRvIHBhZGRpbmc/XG4gICAgICBpZiAoIShyMCA+IGVwc2lsb24kMSkgfHwgIShkYTAgPiBlcHNpbG9uJDEpKSB7IGNvbnRleHQubGluZVRvKHgxMCwgeTEwKTsgfVxuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIGlubmVyIHJpbmcgKG9yIHBvaW50KSBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMCA+IGVwc2lsb24kMSkge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMCA8IHJjKSB7IGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTsgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksIGN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMCwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIGlubmVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgeyBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEwLCBhMDAsIGN3KTsgfVxuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBpZiAoYnVmZmVyKSB7IHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsOyB9XG4gIH1cblxuICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9ICgraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIsXG4gICAgICAgIGEgPSAoK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSBwaSQxIC8gMjtcbiAgICByZXR1cm4gW2NvcyhhKSAqIHIsIHNpbihhKSAqIHJdO1xuICB9O1xuXG4gIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogaW5uZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG91dGVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBvdXRlclJhZGl1cztcbiAgfTtcblxuICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvcm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogY29ybmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkUmFkaXVzID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXywgYXJjKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyYztcbn1cblxudmFyIENpcmNsZSA9IHtcbiAgbmFtZTogJ0xhTW90aW9uQ2lyY2xlJyxcblxuICBmdW5jdGlvbmFsOiB0cnVlLFxuXG4gIHByb3BzOiBbJ3InLCAndHJhbnNpdGlvbiddLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIHJlZikge1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG5cbiAgICB2YXIgaWQgPSBcImxhLWNpcmNsZS1cIiArIChwYXJlbnQuX3VpZCk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSBwcm9wcy50cmFuc2l0aW9uO1xuXG4gICAgcmV0dXJuIGgoJ2cnLCBbXG4gICAgICBoKCdkZWZzJywgW1xuICAgICAgICBoKFxuICAgICAgICAgICdjbGlwUGF0aCcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBoKFxuICAgICAgICAgICAgICBUcmFucyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IDBcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGgoJ2NpcmNsZScsIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IHByb3BzLnIgKiAxLjVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApXG4gICAgICAgICAgXVxuICAgICAgICApXG4gICAgICBdKSxcbiAgICAgIGgoXG4gICAgICAgICdnJyxcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAnY2xpcC1wYXRoJzogKFwidXJsKCNcIiArIGlkICsgXCIpXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlblxuICAgICAgKVxuICAgIF0pXG4gIH1cbn1cblxudmFyIFBpZSA9IHtcbiAgbmFtZTogJ0xhUGllJyxcblxuICBtaXhpbnM6IFtwb2xhcl0sXG5cbiAgcHJvcHM6IHtcbiAgICB0cmFuc2xhdGU6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5XSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFsnNTAlJywgJzUwJSddOyB9XG4gICAgfSxcblxuICAgIHJhZGl1czoge1xuICAgICAgdHlwZTogW051bWJlciwgQXJyYXldLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gWzAsIDEwMF07IH1cbiAgICB9LFxuXG4gICAgYW5nbGVzOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBBcnJheV0sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbMCwgTWF0aC5QSSAqIDJdOyB9XG4gICAgfSxcblxuICAgIHNob3dMYWJlbDogQm9vbGVhbixcblxuICAgIGxhYmVsUHJvcDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2xhYmVsJ1xuICAgIH1cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIGFyY3M6IGZ1bmN0aW9uIGFyY3MoKSB7XG4gICAgICByZXR1cm4gcGllKClcbiAgICAgICAgLnN0YXJ0QW5nbGUodGhpcy5jdXJBbmdsZXNbMF0pXG4gICAgICAgIC5lbmRBbmdsZSh0aGlzLmN1ckFuZ2xlc1sxXSlcbiAgICAgICAgLnNvcnRWYWx1ZXMobm9vcCkodGhpcy5yYXdzKVxuICAgIH0sXG5cbiAgICBjdXJSYWRpdXM6IGZ1bmN0aW9uIGN1clJhZGl1cygpIHtcbiAgICAgIHZhciBpbm5lclJhZGl1cyA9IGlzQXJyKHRoaXMucmFkaXVzKSA/IHRoaXMucmFkaXVzWzBdIDogMDtcbiAgICAgIHZhciBvdXRlclJhZGl1cyA9IGlzQXJyKHRoaXMucmFkaXVzKSA/IHRoaXMucmFkaXVzWzFdIDogMTAwO1xuXG4gICAgICBpZiAodGhpcy5taW4gJiYgdGhpcy4kcGFyZW50LmZpbGxDb250YWluZXIpIHtcbiAgICAgICAgb3V0ZXJSYWRpdXMgPSB0aGlzLm1pbiAvIDI7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd0xhYmVsKSB7XG4gICAgICAgICAgb3V0ZXJSYWRpdXMgLT0gdGhpcy5taW4gLyA0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzXVxuICAgIH0sXG5cbiAgICBjdXJBbmdsZXM6IGZ1bmN0aW9uIGN1ckFuZ2xlcygpIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGFuZ2xlcyA9IHJlZi5hbmdsZXM7XG5cbiAgICAgIHJldHVybiBpc0FycihhbmdsZXMpID8gYW5nbGVzIDogWzAsIGFuZ2xlc11cbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHJldHVybiBhcmMoKVxuICAgICAgICAuaW5uZXJSYWRpdXModGhpcy5jdXJSYWRpdXNbMF0pXG4gICAgICAgIC5vdXRlclJhZGl1cyh0aGlzLmN1clJhZGl1c1sxXSlcbiAgICB9LFxuXG4gICAgZHJhd1RleHQ6IGZ1bmN0aW9uIGRyYXdUZXh0KCkge1xuICAgICAgcmV0dXJuIGFyYygpXG4gICAgICAgIC5pbm5lclJhZGl1cygodGhpcy4kcGFyZW50LmZpbGxDb250YWluZXIgPyAwIDogdGhpcy5jdXJSYWRpdXNbMV0pICogMC43KVxuICAgICAgICAub3V0ZXJSYWRpdXMoKHRoaXMuJHBhcmVudC5maWxsQ29udGFpbmVyID8gdGhpcy5taW4gOiB0aGlzLmN1clJhZGl1c1sxXSkgKiAwLjcpXG4gICAgfSxcblxuICAgIGRyYXdUZXh0TGFiZWxzOiBmdW5jdGlvbiBkcmF3VGV4dExhYmVscygpIHtcbiAgICAgIHZhciBpbm5lclJhZGl1cyA9IHRoaXMuJHBhcmVudC5maWxsQ29udGFpbmVyID8gKHRoaXMucmFkaXVzWzBdICsgdGhpcy5taW4gLyA1KSA6IHRoaXMuY3VyUmFkaXVzWzFdICogMC43O1xuICAgICAgdmFyIG91dGVyUmFkaXVzID0gdGhpcy4kcGFyZW50LmZpbGxDb250YWluZXIgPyAodGhpcy5yYWRpdXNbMF0gKyB0aGlzLm1pbiAvIDUpIDogdGhpcy5jdXJSYWRpdXNbMV0gKiAwLjc7XG5cbiAgICAgIHJldHVybiBhcmMoKVxuICAgICAgICAuaW5uZXJSYWRpdXMoaW5uZXJSYWRpdXMpXG4gICAgICAgIC5vdXRlclJhZGl1cyhvdXRlclJhZGl1cylcbiAgICB9LFxuXG4gICAgbWluOiBmdW5jdGlvbiBtaW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcGFyZW50Lm1pblxuICAgIH0sXG5cbiAgICB2YWx1ZVNsb3Q6IGZ1bmN0aW9uIHZhbHVlU2xvdCgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuc2hvd1ZhbHVlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGggPSB0aGlzLiRjcmVhdGVFbGVtZW50O1xuXG4gICAgICByZXR1cm4gdGhpcy5hcmNzLm1hcChmdW5jdGlvbiAoYXJjJCQxLCBpKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMkMS5kcmF3VGV4dC5jZW50cm9pZChhcmMkJDEpO1xuXG4gICAgICAgIHJldHVybiBoKFxuICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICB4OiBwb2ludFswXSxcbiAgICAgICAgICAgICAgeTogcG9pbnRbMV0sXG4gICAgICAgICAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogJ21pZGRsZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoaXMkMS5yYXdzW2ldXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGxhYmVsczogZnVuY3Rpb24gbGFiZWxzKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgbGFiZWxQcm9wID0gcmVmLmxhYmVsUHJvcDtcbiAgICAgIHZhciBQbGFuZSA9IHJlZi5QbGFuZTtcblxuICAgICAgcmV0dXJuIGxhYmVsUHJvcCA/IFBsYW5lLmRhdGEubWFwKGZ1bmN0aW9uIChvKSB7IHJldHVybiBvW2xhYmVsUHJvcF07IH0pIDogbnVsbFxuICAgIH0sXG5cbiAgICBsYWJlbFNsb3Q6IGZ1bmN0aW9uIGxhYmVsU2xvdCgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuc2hvd0xhYmVsKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQ7XG5cbiAgICAgIHJldHVybiB0aGlzLmFyY3MubWFwKGZ1bmN0aW9uIChhcmMkJDEsIGkpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcyQxLmRyYXdUZXh0TGFiZWxzLmNlbnRyb2lkKGFyYyQkMSk7XG5cbiAgICAgICAgcmV0dXJuIGgoXG4gICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHg6IChwb2ludFswXSAqIDAuOTUpIDw8IDEsXG4gICAgICAgICAgICAgIHk6IChwb2ludFsxXSAqIDAuOTUpIDw8IDEsXG4gICAgICAgICAgICAgIGZpbGw6ICcjMDAwJyxcbiAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogJ21pZGRsZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoaXMkMS5sYWJlbHNbaV1cbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXMuUGxhbmU7XG4gICAgdmFyIGdlbkNvbG9yID0gcmVmLmdlbkNvbG9yO1xuICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgdmFyIGFuaW1hdGVkID0gcmVmJDEuYW5pbWF0ZWQ7XG4gICAgdmFyIGFyY3MgPSByZWYkMS5hcmNzO1xuICAgIHZhciBkcmF3ID0gcmVmJDEuZHJhdztcbiAgICB2YXIgcGF0aHMgPSBhcmNzLm1hcChkcmF3KS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiBoKCdwYXRoJywge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGQ6IGQsXG4gICAgICAgICAgZmlsbDogZ2VuQ29sb3IoaSksXG4gICAgICAgICAgc3Ryb2tlOiAnI2ZmZidcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KTtcbiAgICB2YXIgc2NvcGVkID0gdGhpcy4kc2NvcGVkU2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgcG9pbnRTbG90ID1cbiAgICAgIHNjb3BlZCAmJlxuICAgICAgYXJjcy5tYXAoZnVuY3Rpb24gKGFyYyQkMSwgaSkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzJDEuZHJhd1RleHQuY2VudHJvaWQoYXJjJCQxKTtcbiAgICAgICAgcmV0dXJuIHNjb3BlZCh7XG4gICAgICAgICAgYXJjOiBhcmMkJDEsXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgeDogcG9pbnRbMF0sXG4gICAgICAgICAgeTogcG9pbnRbMV0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMkMS50cmFuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIHZhciBub2RlcyA9IFtdLmNvbmNhdChwYXRocywgdGhpcy52YWx1ZVNsb3QsIHRoaXMubGFiZWxTbG90LCBwb2ludFNsb3QpO1xuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB0cmFuc2Zvcm06IChcInRyYW5zbGF0ZShcIiArICh0aGlzLnRyYW5zbGF0ZSkgKyBcIilcIilcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGFuaW1hdGVkKSB7XG4gICAgICByZXR1cm4gaCgnZycsIGRhdGEsIFtcbiAgICAgICAgaChcbiAgICAgICAgICBDaXJjbGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy50cmFucyxcbiAgICAgICAgICAgICAgcjogdGhpcy5jdXJSYWRpdXNbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5vZGVzXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGgoJ2cnLCBkYXRhLCBub2RlcylcbiAgfVxufVxuXG52YXIgb2JqZWN0ID0ge1xuICBtaXhpbnM6IFtiYXNpY10sXG5cbiAgcHJvcHM6IHtcbiAgICBjb2xvcjogU3RyaW5nXG4gIH0sXG5cbiAgdHlwZTogJ29iamVjdCcsXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBjdXJDb2xvcjogZnVuY3Rpb24gY3VyQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb2xvciB8fCB0aGlzLlBsYW5lLnRleHRDb2xvclxuICAgIH1cbiAgfVxufVxuXG52YXIgQ0FQX0hFSUdIVCA9IDAuNzE7XG5cbnZhciBheGVzID0ge1xuICBwcm9wczoge1xuICAgIGNvbG9yOiBTdHJpbmcsXG5cbiAgICB0aWNrU2l6ZToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogNVxuICAgIH0sXG5cbiAgICBmb250U2l6ZToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMTVcbiAgICB9LFxuXG4gICAgZm9ybWF0OiBGdW5jdGlvbixcblxuICAgIGdyaWRsaW5lOiBCb29sZWFuLFxuXG4gICAgZ3JpZGxpbmVJbnRlcnZhbDogW0Z1bmN0aW9uLCBOdW1iZXJdLFxuXG4gICAgaW50ZXJ2YWw6IFtGdW5jdGlvbiwgTnVtYmVyXSxcblxuICAgIHRpY2tzOiBBcnJheSxcblxuICAgIG5iVGlja3M6IE51bWJlclxuICB9LFxuXG4gIG1peGluczogW29iamVjdCwgdmFsdWVzLCBkYXNoZWRdLFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNYOiBmdW5jdGlvbiBpc1goKSB7XG4gICAgICByZXR1cm4gdGhpcy4kb3B0aW9ucy5heGlzID09PSAneCdcbiAgICB9LFxuXG4gICAgbGFiZWxzOiBmdW5jdGlvbiBsYWJlbHMoKSB7XG4gICAgICB2YXIgcmF3cyA9IHRoaXMucmF3cztcbiAgICAgIHZhciBib2FyZCA9IHRoaXMuUGxhbmU7XG4gICAgICB2YXIgbGVuZ3RoID0gYm9hcmQubGVuO1xuXG4gICAgICBpZiAodGhpcy5pc1gpIHtcbiAgICAgICAgcmF3cyA9IHJhd3MgfHwgQXJyYXkuYXBwbHkobnVsbCwge2xlbmd0aDogbGVuZ3RofSkubWFwKGZ1bmN0aW9uIChuLCBpKSB7IHJldHVybiBpICsgMTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXdzID0gZ2VuVGlja3MoYm9hcmQubG93LCBib2FyZC5oaWdoLCBsZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF3c1xuICAgIH0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uIGdhcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzWCA/IHRoaXMuUGxhbmUuZ2FwIDogMFxuICAgIH0sXG5cbiAgICBwb2ludHM6IGZ1bmN0aW9uIHBvaW50cygpIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGJvYXJkID0gcmVmLlBsYW5lO1xuICAgICAgdmFyIGlzWCA9IHJlZi5pc1g7XG4gICAgICB2YXIgbGFiZWxzID0gcmVmLmxhYmVscztcbiAgICAgIHZhciBpbnZlcnNlID0gcmVmLmludmVyc2U7XG4gICAgICB2YXIgZ2FwID0gcmVmLmdhcDtcbiAgICAgIHZhciByZWYkMSA9IGJvYXJkLmNhbnZhcztcbiAgICAgIHZhciB4MCA9IHJlZiQxLngwO1xuICAgICAgdmFyIHkwID0gcmVmJDEueTA7XG4gICAgICB2YXIgeTEgPSByZWYkMS55MTtcbiAgICAgIHZhciB3aWR0aCA9IHJlZiQxLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHJlZiQxLmhlaWdodDtcbiAgICAgIHZhciBwb2ludHM7XG5cbiAgICAgIGlmIChpc1gpIHtcbiAgICAgICAgdmFyIHhSYXRpbyA9IGJvYXJkLnhSYXRpbztcbiAgICAgICAgdmFyIG9mZnNldCA9IGludmVyc2UgPyAwIDogaGVpZ2h0O1xuICAgICAgICB2YXIgeSA9IHkwICsgb2Zmc2V0O1xuXG4gICAgICAgIHBvaW50cyA9IGxhYmVscy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgdmFyIHggPSB4MCArIHhSYXRpbyAqIGkgKyBnYXA7XG5cbiAgICAgICAgICByZXR1cm4gW3gsIHldXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHlSYXRpbyA9IGJvYXJkLnlSYXRpbztcbiAgICAgICAgdmFyIGxvdyA9IGJvYXJkLmxvdztcbiAgICAgICAgdmFyIG9mZnNldCQxID0gaW52ZXJzZSA/IHdpZHRoIDogMDtcbiAgICAgICAgdmFyIHggPSB4MCArIG9mZnNldCQxO1xuXG4gICAgICAgIHBvaW50cyA9IGxhYmVscy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHkgPSB5MSAtICh2YWx1ZSAtIGxvdykgKiB5UmF0aW87XG5cbiAgICAgICAgICByZXR1cm4gW3gsIHldXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnRzXG4gICAgfSxcblxuICAgIGN1ckNvbG9yOiBmdW5jdGlvbiBjdXJDb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbG9yIHx8IHRoaXMuUGxhbmUudGV4dENvbG9yXG4gICAgfSxcblxuICAgIGhhbmRsZUludGVydmFsOiBmdW5jdGlvbiBoYW5kbGVJbnRlcnZhbCgpIHtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGludGVydmFsID0gcmVmLmludGVydmFsO1xuXG4gICAgICBpZiAodHlwZW9mIGludGVydmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAlIGludGVydmFsID09PSAwXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm4oaW50ZXJ2YWwpKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnZhbFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVHcmlkbGluZUludGVydmFsOiBmdW5jdGlvbiBoYW5kbGVHcmlkbGluZUludGVydmFsKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgZ3JpZGxpbmVJbnRlcnZhbCA9IHJlZi5ncmlkbGluZUludGVydmFsO1xuXG4gICAgICBpZiAodHlwZW9mIGdyaWRsaW5lSW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpICUgZ3JpZGxpbmVJbnRlcnZhbCA9PT0gMFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZuKGdyaWRsaW5lSW50ZXJ2YWwpKSB7XG4gICAgICAgIHJldHVybiBncmlkbGluZUludGVydmFsXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgJ3N0b3JlLmFjdGl2ZWRJbmRleCc6IGZ1bmN0aW9uIHN0b3JlX2FjdGl2ZWRJbmRleChpbmRleCkge1xuICAgICAgaWYgKHRoaXMuaXNYKSB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0b3JlLCAnYWN0aXZlZExhYmVsJywgdGhpcy5sYWJlbHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIHRpY2tzID0gcmVmLnRpY2tzO1xuXG4gICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICB2YXIgbmJUaWNrcyA9IHJlZiQxLm5iVGlja3M7XG4gICAgdmFyIHBvaW50cyA9IHJlZiQxLnBvaW50cztcbiAgICB2YXIgbGFiZWxzID0gcmVmJDEubGFiZWxzO1xuICAgIHZhciB0aWNrU2l6ZSA9IHJlZiQxLnRpY2tTaXplO1xuICAgIHZhciBmb250U2l6ZSA9IHJlZiQxLmZvbnRTaXplO1xuICAgIHZhciBjdXJDb2xvciA9IHJlZiQxLmN1ckNvbG9yO1xuICAgIHZhciBpc1ggPSByZWYkMS5pc1g7XG4gICAgdmFyIGZvcm1hdCA9IHJlZiQxLmZvcm1hdDtcbiAgICB2YXIgaW52ZXJzZSA9IHJlZiQxLmludmVyc2U7XG4gICAgdmFyIGdhcCA9IHJlZiQxLmdhcDtcbiAgICB2YXIgYm9hcmQgPSByZWYkMS5QbGFuZTtcbiAgICB2YXIgc3RvcmUgPSByZWYkMS5zdG9yZTtcbiAgICB2YXIgZmlyc3QgPSBwb2ludHNbMF07XG4gICAgdmFyIGVuZCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHRzcGFuU2xvdCA9IHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQ7XG5cbiAgICB2YXIgbGluZVNpemUgPSAoaW52ZXJzZSA/IC0xIDogMSkgKiB0aWNrU2l6ZTtcbiAgICB2YXIgeUxpbmVPZmZzZXQgPSAoaXNYID8gMSA6IDApICogbGluZVNpemU7XG4gICAgdmFyIHhMaW5lT2Zmc2V0ID0gKGlzWCA/IDAgOiAxKSAqIGxpbmVTaXplO1xuICAgIHZhciB0ZXh0QWxpZ24gPSBpc1ggPyAnbWlkZGxlJyA6IGludmVyc2UgPyAnc3RhcnQnIDogJ2VuZCc7XG4gICAgdmFyIHNwYW5ZT2Zmc2V0ID0gaXNYID9cbiAgICAgIGludmVyc2UgPyBDQVBfSEVJR0hUIC0gMSA6IENBUF9IRUlHSFQgOlxuICAgICAgQ0FQX0hFSUdIVCAvIDI7XG4gICAgdmFyIHRleHRZT2Zmc2V0ID0gKGlzWCA/IGxpbmVTaXplIDogMCkgKiAxLjU7XG4gICAgdmFyIHRleHRYT2Zmc2V0ID0gKGlzWCA/IDAgOiBsaW5lU2l6ZSkgKiAxLjU7XG5cbiAgICBpZiAodGlja3MgfHwgbmJUaWNrcykge1xuICAgICAgdmFyIHlCYXNpcyA9IGJvYXJkLmhlaWdodCAtIGJvYXJkLm9mZnNldFsyXTtcblxuICAgICAgaWYgKG5iVGlja3MpIHtcbiAgICAgICAgdGlja3MgPSBnZW5FeGFjdE5iVGlja3MoYm9hcmQubG93LCBib2FyZC5oaWdoLCBuYlRpY2tzKTtcbiAgICAgIH1cblxuICAgICAgdGlja3MgPSB0aWNrcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBoKCdnJywgW1xuICAgICAgICAgIHRpY2tTaXplICYmXG4gICAgICAgICAgICBoKCdsaW5lJywge1xuICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHgxOiAwIC0geExpbmVPZmZzZXQgKyBib2FyZC5vZmZzZXRbM10sXG4gICAgICAgICAgICAgICAgeDI6IDYgLSB4TGluZU9mZnNldCArIGJvYXJkLm9mZnNldFszXSxcbiAgICAgICAgICAgICAgICB5MTogeUJhc2lzIC0gdmFsdWUgKiBib2FyZC55UmF0aW8sXG4gICAgICAgICAgICAgICAgeTI6IHlCYXNpcyAtIHZhbHVlICogYm9hcmQueVJhdGlvIC0geUxpbmVPZmZzZXQsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBjdXJDb2xvclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBoKFxuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHg6IDAgLSB0ZXh0WE9mZnNldCArIGJvYXJkLm9mZnNldFszXSxcbiAgICAgICAgICAgICAgICB5OlxuICAgICAgICAgICAgICAgICAgYm9hcmQuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgIGJvYXJkLm9mZnNldFsyXSAtXG4gICAgICAgICAgICAgICAgICB2YWx1ZSAqIGJvYXJkLnlSYXRpbyAtXG4gICAgICAgICAgICAgICAgICB0ZXh0WU9mZnNldCxcbiAgICAgICAgICAgICAgICBkeTogc3BhbllPZmZzZXQgKyAnZW0nLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0c3BhblNsb3QgP1xuICAgICAgICAgICAgICB0c3BhblNsb3Qoe3ZhbHVlOiB2YWx1ZX0pIDpcbiAgICAgICAgICAgICAgaXNGbihmb3JtYXQpID8gZm9ybWF0KHZhbHVlKSA6IHZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICBdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzID0gbGFiZWxzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgICAgaWYgKHRoaXMkMS5oYW5kbGVJbnRlcnZhbCAmJiAhdGhpcyQxLmhhbmRsZUludGVydmFsKGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaCgnZycsIFtcbiAgICAgICAgICAgIHRpY2tTaXplICYmXG4gICAgICAgICAgICAgIGgoJ2xpbmUnLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgIHgxOiBwb2ludFswXSAtIHhMaW5lT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgeDI6IHBvaW50WzBdLFxuICAgICAgICAgICAgICAgICAgeTE6IHBvaW50WzFdICsgeUxpbmVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICB5MjogcG9pbnRbMV0sXG4gICAgICAgICAgICAgICAgICBzdHJva2U6IGN1ckNvbG9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGgoXG4gICAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICB4OiBwb2ludFswXSAtIHRleHRYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgeTogcG9pbnRbMV0gKyB0ZXh0WU9mZnNldCxcbiAgICAgICAgICAgICAgICAgIGR5OiBzcGFuWU9mZnNldCArICdlbScsXG4gICAgICAgICAgICAgICAgICBzdHJva2U6ICdub25lJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHNwYW5TbG90ID9cbiAgICAgICAgICAgICAgICB0c3BhblNsb3Qoe3ZhbHVlOiB2YWx1ZX0pIDpcbiAgICAgICAgICAgICAgICBpc0ZuKGZvcm1hdCkgPyBmb3JtYXQodmFsdWUpIDogdmFsdWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH1cblxuICAgIHJldHVybiBoKFxuICAgICAgJ2cnLFxuICAgICAge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHN0cm9rZTogY3VyQ29sb3JcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgaCgnbGluZScsIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgeDI6IGVuZFswXSArIGdhcCxcbiAgICAgICAgICAgIHkyOiBlbmRbMV0sXG4gICAgICAgICAgICB4MTogZmlyc3RbMF0gLSBnYXAsXG4gICAgICAgICAgICB5MTogZmlyc3RbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBbXG4gICAgICAgICAgaChcbiAgICAgICAgICAgICdnJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAndGV4dC1hbmNob3InOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgIGZpbGw6IGN1ckNvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aWNrc1xuICAgICAgICAgIClcbiAgICAgICAgXS5jb25jYXQoXG4gICAgICAgICAgdGhpcy5ncmlkbGluZSAmJlxuICAgICAgICAgICAgcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBwLCBpKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhdGhpcyQxLmhhbmRsZUdyaWRsaW5lSW50ZXJ2YWwgfHxcbiAgICAgICAgICAgICAgICB0aGlzJDEuaGFuZGxlR3JpZGxpbmVJbnRlcnZhbChpKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhbGwucHVzaChcbiAgICAgICAgICAgICAgICAgIGgoJ2xpbmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgeDE6IHBbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgeTE6IHBbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgeDI6IGlzWCA/IHBbMF0gOiBib2FyZC5jYW52YXMueDEsXG4gICAgICAgICAgICAgICAgICAgICAgeTI6IGlzWCA/IGJvYXJkLmNhbnZhcy55MCA6IHBbMV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBpc1ggJiYgc3RvcmUuYWN0aXZlZEluZGV4ID09PSBpID8gMSA6IDAuMyxcbiAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IHRoaXMkMS5jdXJEYXNoZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhbGxcbiAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICApXG4gICAgICBdXG4gICAgKVxuICB9XG59XG5cbnZhciBYQXhpcyA9IHtcbiAgbmFtZTogJ0xhWEF4aXMnLFxuXG4gIGF4aXM6ICd4JyxcblxuICBzcGFjZTogWzAsIDIwLCAyNCwgMjBdLFxuXG4gIG1peGluczogW2F4ZXNdXG59XG5cbnZhciBZQXhpcyA9IHtcbiAgbmFtZTogJ0xhWUF4aXMnLFxuXG4gIGF4aXM6ICd5JyxcblxuICBzcGFjZTogWzEwLCAwLCAwLCA0MF0sXG5cbiAgbWl4aW5zOiBbYXhlc11cbn1cblxudmFyIFhBeGlzSW52ZXJzZSA9IHtcbiAgbmFtZTogJ0xhWEF4aXNJbnZlcnNlJyxcblxuICBzcGFjZTogWzI0LCAyMCwgMCwgMjBdLFxuXG4gIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlKCkge1xuICAgIHRoaXMuaW52ZXJzZSA9IHRydWU7XG4gIH0sXG5cbiAgbWl4aW5zOiBbWEF4aXNdXG59XG5cbnZhciBZQXhpc0ludmVyc2UgPSB7XG4gIG5hbWU6ICdMYVlBeGlzSW52ZXJzZScsXG5cbiAgc3BhY2U6IFsxMCwgNDAsIDAsIDBdLFxuXG4gIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlKCkge1xuICAgIHRoaXMuaW52ZXJzZSA9IHRydWU7XG4gIH0sXG5cbiAgbWl4aW5zOiBbWUF4aXNdXG59XG5cbnZhciBZTWFya2VyID0ge1xuICBuYW1lOiAnTGFZTWFya2VyJyxcblxuICBtaXhpbnM6IFtvYmplY3QsIGRhc2hlZF0sXG5cbiAgcHJvcHM6IHtcbiAgICBsYWJlbDogU3RyaW5nLFxuXG4gICAgdmFsdWU6IE51bWJlcixcblxuICAgIHBsYWNlbWVudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2VuZCdcbiAgICB9XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBwb2ludDogZnVuY3Rpb24gcG9pbnQoKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcy5QbGFuZTtcbiAgICAgIHZhciB5UmF0aW8gPSByZWYueVJhdGlvO1xuICAgICAgdmFyIGxvdyA9IHJlZi5sb3c7XG4gICAgICB2YXIgY2FudmFzID0gcmVmLmNhbnZhcztcbiAgICAgIHZhciB4MCA9IGNhbnZhcy54MDtcbiAgICAgIHZhciB5MSA9IGNhbnZhcy55MTtcbiAgICAgIHZhciB4MSA9IGNhbnZhcy54MTtcbiAgICAgIHZhciB5ID0geTEgLSAodGhpcy52YWx1ZSAtIGxvdykgKiB5UmF0aW87XG5cbiAgICAgIHJldHVybiB7eDE6IHgwLCB5MTogeSwgeTI6IHksIHgyOiB4MX1cbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBwb2ludCA9IHJlZi5wb2ludDtcbiAgICB2YXIgY3VyQ29sb3IgPSByZWYuY3VyQ29sb3I7XG4gICAgdmFyIGN1ckRhc2hlZCA9IHJlZi5jdXJEYXNoZWQ7XG4gICAgdmFyIGxhYmVsID0gcmVmLmxhYmVsO1xuICAgIHZhciBwbGFjZW1lbnQgPSByZWYucGxhY2VtZW50O1xuXG4gICAgcmV0dXJuIGgoXG4gICAgICAnZycsXG5cbiAgICAgIFtcbiAgICAgICAgaCgnbGluZScsIHtcbiAgICAgICAgICBhdHRyczogcG9pbnQsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogY3VyQ29sb3IsXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IGN1ckRhc2hlZFxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGxhYmVsICYmXG4gICAgICAgICAgaChcbiAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBmaWxsOiBjdXJDb2xvcixcbiAgICAgICAgICAgICAgICB4OlxuICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09PSAnZW5kJyA/XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LngyIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09PSAnc3RhcnQnID9cbiAgICAgICAgICAgICAgICAgICAgICBwb2ludC54MSA6XG4gICAgICAgICAgICAgICAgICAgICAgKHBvaW50LngyIC0gcG9pbnQueDEpIC8gMiArIHBvaW50LngxLFxuICAgICAgICAgICAgICAgIHk6IHBvaW50LnkxLFxuICAgICAgICAgICAgICAgIGR5OiAnLTAuMzFlbScsXG4gICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogcGxhY2VtZW50XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbFxuICAgICAgICAgIClcbiAgICAgIF1cbiAgICApXG4gIH1cbn1cblxudmFyIFlSZWdpb24gPSB7XG4gIG5hbWU6ICdMYVlSZWdpb24nLFxuXG4gIG1peGluczogW29iamVjdCwgZGFzaGVkXSxcblxuICBwcm9wczoge1xuICAgIGxhYmVsOiBTdHJpbmcsXG5cbiAgICBsb3c6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcblxuICAgIGhpZ2g6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcblxuICAgIGZpbGxDb2xvcjogU3RyaW5nLFxuXG4gICAgcGxhY2VtZW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZW5kJ1xuICAgIH1cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHBvaW50OiBmdW5jdGlvbiBwb2ludCgpIHtcbiAgICAgIHZhciByZWYgPSB0aGlzLlBsYW5lO1xuICAgICAgdmFyIHlSYXRpbyA9IHJlZi55UmF0aW87XG4gICAgICB2YXIgbG93ID0gcmVmLmxvdztcbiAgICAgIHZhciBjYW52YXMgPSByZWYuY2FudmFzO1xuICAgICAgdmFyIHgwID0gY2FudmFzLngwO1xuICAgICAgdmFyIHkxID0gY2FudmFzLnkxO1xuICAgICAgdmFyIHdpZHRoID0gY2FudmFzLndpZHRoO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4MCxcbiAgICAgICAgeTogeTEgLSAodGhpcy5oaWdoIC0gbG93KSAqIHlSYXRpbyxcbiAgICAgICAgaGVpZ2h0OiAodGhpcy5oaWdoIC0gdGhpcy5sb3cpICogeVJhdGlvLFxuICAgICAgICB3aWR0aDogd2lkdGhcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlsbEF0dHI6IGZ1bmN0aW9uIGZpbGxBdHRyKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgZmlsbENvbG9yID0gcmVmLmZpbGxDb2xvcjtcblxuICAgICAgcmV0dXJuIGZpbGxDb2xvciA/XG4gICAgICAgIHtcbiAgICAgICAgICBmaWxsOiBmaWxsQ29sb3IsXG4gICAgICAgICAgc3Ryb2tlOiB0aGlzLmN1ckNvbG9yXG4gICAgICAgIH0gOlxuICAgICAgICB7XG4gICAgICAgICAgc3Ryb2tlOiB0aGlzLmN1ckNvbG9yLFxuICAgICAgICAgIG9wYWNpdHk6IDAuM1xuICAgICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgbGFiZWwgPSByZWYubGFiZWw7XG4gICAgdmFyIHBvaW50ID0gcmVmLnBvaW50O1xuICAgIHZhciBwbGFjZW1lbnQgPSByZWYucGxhY2VtZW50O1xuICAgIHZhciBmaWxsQXR0ciA9IHJlZi5maWxsQXR0cjtcblxuICAgIGlmICh0aGlzLmhpZ2ggPCB0aGlzLmxvdykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmV0dXJuIGgoXG4gICAgICAnZycsXG4gICAgICB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgZmlsbDogdGhpcy5jdXJDb2xvclxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBoKCdyZWN0Jywge1xuICAgICAgICAgIGF0dHJzOiBleHRlbmQoZmlsbEF0dHIsIHBvaW50KSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiB0aGlzLmN1ckRhc2hlZFxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGxhYmVsICYmXG4gICAgICAgICAgaChcbiAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICB4OlxuICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09PSAnZW5kJyA/XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnggKyBwb2ludC53aWR0aCA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PT0gJ3N0YXJ0JyA/XG4gICAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA6XG4gICAgICAgICAgICAgICAgICAgICAgcG9pbnQud2lkdGggLyAyICsgcG9pbnQueCxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55LFxuICAgICAgICAgICAgICAgIGR5OiAnLTAuMzFlbScsXG4gICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogcGxhY2VtZW50XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbFxuICAgICAgICAgIClcbiAgICAgIF1cbiAgICApXG4gIH1cbn1cblxudmFyIHdpZGdldCA9IHtcbiAgdHlwZTogJ3dpZGdldCcsXG5cbiAgbWl4aW5zOiBbYmFzaWNdXG59XG5cbnZhciBUb29sdGlwID0ge1xuICBuYW1lOiAnTGFUb29sdGlwJyxcblxuICBtaXhpbnM6IFt3aWRnZXQsIGFuaW1hdGVdLFxuXG4gIHByb3BzOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IHtcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH1cbiAgfSxcblxuICBkYXRhOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHNob3c6IGZhbHNlXG4gIH0pOyB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVNb3ZlOiBmdW5jdGlvbiBoYW5kbGVNb3ZlKHJlZikge1xuICAgICAgdmFyIHggPSByZWYueDtcbiAgICAgIHZhciB5ID0gcmVmLnk7XG5cbiAgICAgIHZhciBib2FyZCA9IHRoaXMuUGxhbmU7XG4gICAgICB2YXIgYm9hcmRSZWN0ID0gYm9hcmQuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHJlY3QgPSB0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciByZWxZID0geSAtIGJvYXJkUmVjdC55O1xuICAgICAgdmFyIHJlbFggPSB4IC0gYm9hcmRSZWN0LnggLSB0aGlzLm9mZnNldFg7XG4gICAgICB2YXIgaW5kZXggPSBNYXRoLnJvdW5kKHJlbFggLyBib2FyZC54UmF0aW8pO1xuICAgICAgdmFyIG1heExlZnQgPSBib2FyZC5jYW52YXMueDEgLSByZWN0LndpZHRoO1xuICAgICAgdmFyIG1heFRvcCA9IGJvYXJkLmNhbnZhcy55MSAtIHJlY3QuaGVpZ2h0O1xuICAgICAgdmFyIG9mZnNldCA9IDEwO1xuXG4gICAgICBpZiAocmVsWSA+PSBib2FyZC5jYW52YXMueTAgJiYgcmVsWSA8PSBib2FyZC5jYW52YXMueTEpIHtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgaW5kZXggPCBib2FyZC5sZW4pIHtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIGluZGV4ICogYm9hcmQueFJhdGlvICsgdGhpcy5vZmZzZXRYICsgb2Zmc2V0LFxuICAgICAgICAgICAgbWF4TGVmdFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3RvcmUsICdhY3RpdmVkSW5kZXgnLCBpbmRleCk7XG4gICAgICAgICAgdGhpcy50b3AgPSBNYXRoLm1pbihyZWxZICsgb2Zmc2V0LCBtYXhUb3ApO1xuICAgICAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZUxlYXZlKCk7XG4gICAgfSxcblxuICAgIGhhbmRsZUxlYXZlOiBmdW5jdGlvbiBoYW5kbGVMZWF2ZSgpIHtcbiAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgdGhpcy4kc2V0KHRoaXMuc3RvcmUsICdhY3RpdmVkSW5kZXgnLCBudWxsKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBvZmZzZXRYOiBmdW5jdGlvbiBvZmZzZXRYKCkge1xuICAgICAgdmFyIGJvYXJkID0gdGhpcy5QbGFuZTtcbiAgICAgIHJldHVybiBib2FyZC5jYW52YXMueDAgKyBib2FyZC5nYXBcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYm9hcmQgPSB0aGlzLlBsYW5lO1xuICAgIHZhciBlbCA9IGJvYXJkLiRlbDtcblxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlKHRoaXMuaGFuZGxlTW92ZSwgMTApKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5oYW5kbGVMZWF2ZSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICd0b3VjaG1vdmUnLFxuICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgICB0aGlzJDEuaGFuZGxlTW92ZSh7eDogdG91Y2guY2xpZW50WCwgeTogdG91Y2guY2xpZW50WX0pO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgICk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciByZWYgPSB0aGlzLnN0b3JlO1xuICAgIHZhciBhY3RpdmVkTGFiZWwgPSByZWYuYWN0aXZlZExhYmVsO1xuICAgIHZhciBhY3RpdmVkUG9pbnQgPSByZWYuYWN0aXZlZFBvaW50OyBpZiAoIGFjdGl2ZWRQb2ludCA9PT0gdm9pZCAwICkgYWN0aXZlZFBvaW50ID0gW107XG4gICAgdmFyIGFjdGl2ZWRJbmRleCA9IHJlZi5hY3RpdmVkSW5kZXg7XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0O1xuICAgIHZhciB0b29sdGlwID0gc2xvdCA/XG4gICAgICBzbG90KHtcbiAgICAgICAgbGFiZWw6IGFjdGl2ZWRMYWJlbCxcbiAgICAgICAgYWN0aXZlZDogYWN0aXZlZFBvaW50LFxuICAgICAgICBpbmRleDogYWN0aXZlZEluZGV4XG4gICAgICB9KSA6XG4gICAgICBoKFxuICAgICAgICAnZGl2JyxcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAnIzAwMDAwMDk1JyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICc4cHgnLFxuICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBoKFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAnLjVlbSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFjdGl2ZWRMYWJlbFxuICAgICAgICAgICksXG4gICAgICAgICAgYWN0aXZlZFBvaW50Lm1hcChmdW5jdGlvbiAoYWN0aXZlKSB7IHJldHVybiBoKCdkaXYnLCBbXG4gICAgICAgICAgICAgIGgoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYWN0aXZlLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTBweCcsXG4gICAgICAgICAgICAgICAgICB3aWR0aDogJzEwcHgnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICc1cHgnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgYWN0aXZlLmxhYmVsICYmXG4gICAgICAgICAgICAgICAgICBoKFxuICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICc1cHgnXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUubGFiZWwgKyAnOidcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGgoJ3NwYW4nLCBhY3RpdmUudmFsdWUpXG4gICAgICAgICAgICBdKTsgfVxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgKTtcblxuICAgIHJldHVybiBoKFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzOiAnbGEtdG9vbHRpcCcsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIHRyYW5zZm9ybTogKFwidHJhbnNsYXRlKFwiICsgKHRoaXMubGVmdCkgKyBcInB4LCBcIiArICh0aGlzLnRvcCkgKyBcInB4KVwiKSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLnRyYW5zLFxuICAgICAgICAgIG9wYWNpdHk6IE51bWJlcih0aGlzLnNob3cpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbdG9vbHRpcF1cbiAgICApXG4gIH1cbn1cblxudmFyIExlZ2VuZCA9IHtcbiAgbmFtZTogJ0xhTGVnZW5kJyxcblxuICBtaXhpbnM6IFt3aWRnZXRdLFxuXG4gIHByb3BzOiB7XG4gICAgc2VsZWN0YWJsZTogQm9vbGVhbixcblxuICAgIC8qKlxuICAgICAqIF4odG9wfGJvdHRvbXxsZWZ0fHJpZ2h0KSgtKHN0YXJ0fGNlbnRlcnxlbmQpKT8kXG4gICAgICovXG4gICAgcGxhY2VtZW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYm90dG9tJ1xuICAgIH0sXG5cbiAgICBjb2xvcjogU3RyaW5nXG4gIH0sXG5cbiAgcHJlbG9hZDogZnVuY3Rpb24gcHJlbG9hZChyZWYpIHtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuXG4gICAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50OyBpZiAoIHBsYWNlbWVudCA9PT0gdm9pZCAwICkgcGxhY2VtZW50ID0gJ2JvdHRvbSc7XG4gICAgdmFyIHNwYWNlID0gWzAsIDAsIDAsIDBdO1xuXG4gICAgc3dpdGNoIChwbGFjZW1lbnQubWF0Y2goL14oXFx3KyktPy8pWzFdKSB7XG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBzcGFjZVsyXSA9IDUwO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgc3BhY2VbMF0gPSA1MDtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBzcGFjZVszXSA9IDEwMDtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgc3BhY2VbMV0gPSAxMDA7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHBhcmVudC5hZGRTcGFjZShzcGFjZSk7XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBjdXJDb2xvcjogZnVuY3Rpb24gY3VyQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb2xvciB8fCB0aGlzLlBsYW5lLnRleHRDb2xvclxuICAgIH0sXG5cbiAgICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbGFjZW1lbnQubWF0Y2goL14oXFx3KykoLShcXHcrKSk/JC8pWzFdXG4gICAgfSxcblxuICAgIGFsaWduOiBmdW5jdGlvbiBhbGlnbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYWNlbWVudC5tYXRjaCgvXihcXHcrKSgtKFxcdyspKT8kLylbM11cbiAgICB9LFxuXG4gICAgcG9zOiBmdW5jdGlvbiBwb3MoKSB7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBwb3NpdGlvbiA9IHJlZi5wb3NpdGlvbjtcbiAgICAgIHZhciBhbGlnbiA9IHJlZi5hbGlnbjtcbiAgICAgIHZhciBwb3MgPSB7fTtcblxuICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgIHBvcy5sZWZ0ID0gMDtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgIHBvcy5yaWdodCA9IDA7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBwb3MubGVmdCA9ICc1MCUnO1xuICAgICAgICAgICAgcG9zLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKC01MCUpJztcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIHBvcy50b3AgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcy5ib3R0b20gPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgcG9zLnRvcCA9IDA7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICBwb3MuYm90dG9tID0gMDtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHBvcy50b3AgPSAnNTAlJztcbiAgICAgICAgICAgIHBvcy50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgtNTAlKSc7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgcG9zLmxlZnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcy5yaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc1xuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuJHNldCh0aGlzLnN0b3JlLCAnaGlkZGVuJywgW10pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgY3VyQ29sb3IgPSByZWYuY3VyQ29sb3I7XG4gICAgdmFyIHBvcyA9IHJlZi5wb3M7XG4gICAgdmFyIHBvc2l0aW9uID0gcmVmLnBvc2l0aW9uO1xuICAgIHZhciBzZWxlY3RhYmxlID0gcmVmLnNlbGVjdGFibGU7XG4gICAgdmFyIHN0b3JlID0gcmVmLnN0b3JlO1xuICAgIHZhciBoaWRkZW4gPSBzdG9yZS5oaWRkZW47XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0O1xuXG4gICAgcmV0dXJuIGgoXG4gICAgICAnZGl2JyxcbiAgICAgIHtcbiAgICAgICAgY2xhc3M6ICdsYS1sZWdlbmQnLFxuICAgICAgICBzdHlsZTogZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIE9iamVjdC5rZXlzKHN0b3JlLnByb3BzKS5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBoKFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/XG4gICAgICAgICAgICAgICAgICAnYmxvY2snIDpcbiAgICAgICAgICAgICAgICAgICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJzEwcHgnLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAnNXB4JyxcbiAgICAgICAgICAgICAgY29sb3I6IGN1ckNvbG9yLFxuICAgICAgICAgICAgICBjdXJzb3I6IHNlbGVjdGFibGUgPyAncG9pbnRlcicgOiAnbnJvbWFsJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQgPSBOdW1iZXIoaWQpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGhpZGRlbi5pbmRleE9mKGlkKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGhpZGRlbi5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaGlkZGVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbG90ID9cbiAgICAgICAgICAgIHNsb3Qoe1xuICAgICAgICAgICAgICBjb2xvcjogc3RvcmUuY29sb3JzW2lkXSxcbiAgICAgICAgICAgICAgbGFiZWw6IHN0b3JlLmxhYmVsc1tpZF0sXG4gICAgICAgICAgICAgIHByb3A6IHN0b3JlLnByb3BzW2lkXVxuICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBoKCdzcGFuJywge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHN0b3JlLmNvbG9yc1tpZF0sXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMHB4JyxcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTBweCcsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJzVweCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBoKFxuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdHlsZTpcbiAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4uaW5kZXhPZihOdW1iZXIoaWQpKSA+IC0xID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dERlY29yYXRpb246ICdsaW5lLXRocm91Z2gnXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdG9yZS5sYWJlbHNbaWRdXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF1cbiAgICAgICAgKTsgfVxuICAgICAgKVxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBMYXVlKFZ1ZSkge1xuICBbXG4gICAgQ2FydGVzaWFuLFxuICAgIFBvbGFyLFxuICAgIExpbmUsXG4gICAgQXJlYSxcbiAgICBCYXIsXG4gICAgUGllLFxuICAgIFhBeGlzLFxuICAgIFlBeGlzLFxuICAgIFhBeGlzSW52ZXJzZSxcbiAgICBZQXhpc0ludmVyc2UsXG4gICAgVG9vbHRpcCxcbiAgICBMZWdlbmQsXG4gICAgWU1hcmtlcixcbiAgICBZUmVnaW9uXG4gIF0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgIFZ1ZS5jb21wb25lbnQoYy5uYW1lLCBjKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IExhdWUsIENhcnRlc2lhbiwgUG9sYXIsIExpbmUsIEFyZWEsIEJhciwgUGllLCBYQXhpcywgWUF4aXMsIFhBeGlzSW52ZXJzZSwgWUF4aXNJbnZlcnNlLCBUb29sdGlwLCBMZWdlbmQsIFlNYXJrZXIsIFlSZWdpb24gfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/laue/dist/laue.js\n");

/***/ })

}]);